"""
티켓 초기화 라우트 - 순차 실행 패턴

티켓 ID를 받아 초기 컨텍스트를 생성하는 엔드포인트를 처리합니다.
순차적으로 티켓 요약 생성과 벡터 검색(유사 티켓 + KB 문서)을 수행합니다.
"""

import json
import time
import logging
from datetime import datetime
from typing import Optional, Dict, Any, List

from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel

from core.llm.manager import get_llm_manager
from core.database.vectordb import vector_db
from ..dependencies import (
    get_tenant_id,
    get_platform, 
    get_domain,
    get_api_key
)

# 로거 설정
logger = logging.getLogger(__name__)

router = APIRouter()

# 응답 모델
class InitResponse(BaseModel):
    """Init 엔드포인트 응답 모델"""
    success: bool
    ticket_id: str
    tenant_id: str
    summary: Optional[str] = None
    similar_tickets: Optional[List[Dict[str, Any]]] = None
    kb_documents: Optional[List[Dict[str, Any]]] = None
    performance: Optional[Dict[str, float]] = None
    error: Optional[str] = None


@router.get("/init/{ticket_id}", response_model=InitResponse)
async def get_initial_context(
    ticket_id: str,
    tenant_id: str = Depends(get_tenant_id),
    platform: str = Depends(get_platform),
    api_key: str = Depends(get_api_key),
    domain: str = Depends(get_domain),
    include_summary: bool = True,
    include_kb_docs: bool = True,
    include_similar_tickets: bool = True,
    top_k_tickets: int = Query(default=3, ge=1, le=10, description="유사 티켓 검색 결과 수"),
    top_k_kb: int = Query(default=3, ge=1, le=10, description="지식베이스 문서 검색 결과 수"),
):
    """
    티켓 초기화 및 컨텍스트 생성 - 순차 실행 패턴
    
    주어진 티켓 ID에 대해 순차적으로 분석을 수행하고 컨텍스트를 생성합니다:
    1. 실시간 요약 생성 (Freshdesk API)
    2. 유사 티켓 검색 (벡터 유사도)
    3. 관련 지식베이스 문서 검색
    
    표준 헤더 (필수):
    - X-Tenant-ID: 테넌트 ID
    - X-Platform: 플랫폼 식별자 (freshdesk)
    - X-API-Key: API 키
    - X-Domain: 플랫폼 도메인 (예: wedosoft.freshdesk.com)
    
    Args:
        ticket_id: 분석할 티켓 ID
        tenant_id: 테넌트 ID (X-Tenant-ID 헤더에서 추출)
        platform: 플랫폼 타입 (X-Platform 헤더에서 추출)
        api_key: API 키 (X-API-Key 헤더에서 추출)
        domain: 플랫폼 도메인 (X-Domain 헤더에서 추출)
        include_summary: 티켓 요약 생성 여부
        include_kb_docs: 지식베이스 문서 포함 여부
        include_similar_tickets: 유사 티켓 포함 여부
        top_k_tickets: 유사 티켓 검색 결과 수
        top_k_kb: 지식베이스 문서 검색 결과 수
        
    Returns:
        InitResponse: 초기화된 컨텍스트 정보
    """
    
    sequential_start_time = time.time()
    
    try:
        logger.info(f"순차 실행 시작 - ticket_id: {ticket_id}, tenant_id: {tenant_id}")
        
        # LLM Manager 및 Qdrant 클라이언트 초기화
        llm_manager = get_llm_manager()
        qdrant_client = vector_db.client
        
        # 샘플 티켓 데이터 구성 (실제로는 Freshdesk API에서 가져옴)
        ticket_data = {
            "id": ticket_id,
            "subject": f"티켓 {ticket_id} 주제",
            "description_text": f"티켓 {ticket_id}의 상세 내용입니다.",
            "tenant_id": tenant_id,
            "platform": platform
        }
        
        # 순차 실행으로 초기화 처리
        result = await llm_manager.execute_init_sequential(
            ticket_data=ticket_data,
            qdrant_client=qdrant_client,
            tenant_id=tenant_id,
            top_k_tickets=top_k_tickets if include_similar_tickets else 0,
            top_k_kb=top_k_kb if include_kb_docs else 0,
            include_summary=include_summary
        )
        
        sequential_execution_time = time.time() - sequential_start_time
        logger.info(f"순차 실행 완료 - ticket_id: {ticket_id}, 총 실행시간: {sequential_execution_time:.2f}초")
        
        # 응답 구성
        response_data = {
            "success": result.get("success", True),
            "ticket_id": ticket_id,
            "tenant_id": tenant_id,
            "performance": {
                "total_time": sequential_execution_time,
                "summary_time": result.get("summary_time", 0),
                "search_time": result.get("search_time", 0)
            }
        }
        
        # 요약 결과 추가
        if include_summary and result.get("summary"):
            response_data["summary"] = result["summary"]
        
        # 유사 티켓 결과 추가
        if include_similar_tickets and result.get("similar_tickets"):
            similar_tickets = result["similar_tickets"]
            if isinstance(similar_tickets, list):
                response_data["similar_tickets"] = similar_tickets[:top_k_tickets]
            else:
                logger.warning(f"유사 티켓 결과가 예상 형식이 아닙니다: {type(similar_tickets)}")
                response_data["similar_tickets"] = []
        
        # KB 문서 결과 추가
        if include_kb_docs and result.get("kb_documents"):
            kb_documents = result["kb_documents"]
            if isinstance(kb_documents, list):
                response_data["kb_documents"] = kb_documents[:top_k_kb]
            else:
                logger.warning(f"KB 문서 결과가 예상 형식이 아닙니다: {type(kb_documents)}")
                response_data["kb_documents"] = []
        
        logger.info(f"Init 엔드포인트 성공 - ticket_id: {ticket_id}")
        return InitResponse(**response_data)
        
    except Exception as e:
        sequential_execution_time = time.time() - sequential_start_time
        logger.error(f"Init 엔드포인트 실패 - ticket_id: {ticket_id}, 오류: {str(e)}, 실행시간: {sequential_execution_time:.2f}초")
        
        # 오류 응답
        return InitResponse(
            success=False,
            ticket_id=ticket_id,
            tenant_id=tenant_id,
            error=str(e),
            performance={
                "total_time": sequential_execution_time
            }
        )


@router.get("/init/{ticket_id}/health")
async def init_health_check(
    ticket_id: str,
    tenant_id: str = Depends(get_tenant_id)
):
    """Init 엔드포인트 헬스체크"""
    try:
        return {
            "status": "healthy",
            "ticket_id": ticket_id,
            "tenant_id": tenant_id,
            "timestamp": datetime.utcnow().isoformat(),
            "pattern": "sequential_execution"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"헬스체크 실패: {str(e)}")
        # Freshdesk 전용 처리 (platform은 항상 "freshdesk")
        search_tenant_id = tenant_id
        
        # 표준 헤더 기반 Freshdesk API 설정
        freshdesk_domain = domain
        freshdesk_api_key = api_key
        
        if not freshdesk_domain or not freshdesk_api_key:
            raise HTTPException(
                status_code=400,
                detail="Freshdesk 도메인과 API 키가 필요합니다. X-Domain 및 X-API-Key 헤더로 제공해주세요."
            )
        
        # Freshdesk API에서 티켓 정보 조회 (표준 헤더 사용)
        ticket_data = await fetcher.fetch_ticket_details(int(ticket_id), domain=freshdesk_domain, api_key=freshdesk_api_key)
        
        if not ticket_data:
            # API 조회 실패 시 벡터 검색 폴백
            ticket_data = vector_db.get_by_id(
                original_id_value=ticket_id, 
                tenant_id=search_tenant_id, 
                doc_type="ticket",
                platform=platform
            )
            
            if not ticket_data:
                raise HTTPException(
                    status_code=404, 
                    detail=f"플랫폼 {platform}에서 티켓 ID {ticket_id}를 찾을 수 없습니다."
                )
            
        # 메타데이터 추출
        ticket_metadata = ticket_data.get("metadata", {}) if isinstance(ticket_data, dict) else ticket_data
        ticket_title = ticket_metadata.get("subject", f"티켓 ID {ticket_id}")
        ticket_body = ticket_metadata.get("text", ticket_metadata.get("description_text", "티켓 본문 정보 없음"))
        
        # 대화 내용 처리 - 원본 대화 내역 추출
        raw_conversations = ticket_data.get("conversations", []) if isinstance(ticket_data, dict) else []
        
        ticket_conversations = []
        
        if isinstance(raw_conversations, list):
            # 원본 형식 보존 (딕셔너리 형태 유지)
            ticket_conversations = raw_conversations
        elif isinstance(raw_conversations, str):
            try:
                parsed_convs = json.loads(raw_conversations)
                if isinstance(parsed_convs, list):
                    ticket_conversations = parsed_convs
                else:
                    ticket_conversations = [{"body_text": str(parsed_convs), "created_at": datetime.now().timestamp()}]
            except json.JSONDecodeError:
                ticket_conversations = [{"body_text": raw_conversations, "created_at": datetime.now().timestamp()}]
        
        # 대화 내역이 없는 경우 대화 요약 사용
        if not ticket_conversations and ticket_metadata.get("conversation_summary"):
            ticket_conversations = [{"body_text": str(ticket_metadata.get("conversation_summary")), 
                                    "created_at": datetime.now().timestamp()}]
        
        # 컨텍스트 ID 생성 (향후 요청을 위한 고유 식별자)
        context_id = f"ctx_{ticket_id}_{int(time.time())}"
        
        # 티켓 정보 구성을 위한 모든 텍스트
        # 대화 내용이 딕셔너리 목록인 경우 각 대화에서 본문을 추출하여 문자열로 변환
        conversation_texts = []
        for conv in ticket_conversations:
            if isinstance(conv, dict):
                # body_text, body, text 등의 필드를 순서대로 시도
                for field in ["body_text", "body", "text", "content", "message"]:
                    if field in conv and conv[field]:
                        conversation_texts.append(str(conv[field]))
                        break
                else:  # for-else: for 루프가 break 없이 완료되면 실행
                    conversation_texts.append(str(conv)[:300])  # 필드를 못 찾은 경우 전체 딕셔너리
            else:
                conversation_texts.append(str(conv))
        
        # 캐시 확인 (async 방식으로 변경)
        cached_summary = None
        include_summary_chain = include_summary
        if include_summary:
            try:
                cached_summary = await ticket_summary_cache.get(ticket_id)
                if cached_summary is not None:
                    include_summary_chain = False
            except Exception as e:
                logger.warning(f"캐시 확인 중 오류: {e}")
                cached_summary = None

        # 컨텍스트 구축 시작 시간
        context_start_time = time.time()
        
        # Phase 1: Langchain RunnableParallel로 병렬 작업 관리
        # 개별 태스크 정의 대신 Langchain 체인이 모든 작업을 처리
        # 기존 asyncio.gather 방식과 동일한 성능을 유지하면서 더 나은 아키텍처 제공
        
        # 작업별 데이터 초기화
        similar_tickets = []
        kb_documents = []
        ticket_summary = None
        task_times = {}  # 각 작업별 소요 시간 저장
        
        # Phase 1: 순차 실행 (병렬 처리 제거로 코드 단순화)
        # 1. 실시간 티켓 요약 (1-2초) → 2. 벡터 검색 (2초)
        try:
            logger.info(f"순차 실행 시작 (ticket_id: {ticket_id})")
            sequential_start_time = time.time()
            
            # 티켓 정보 구성
            ticket_info = {
                "id": ticket_id,
                "subject": ticket_title,
                "description": ticket_body,
                "conversations": ticket_conversations or [],
                "metadata": ticket_metadata
            }
            
            # 순차 실행 (단순하고 빠름)
            chain_results = await llm_manager.execute_init_sequential(
                ticket_data=ticket_info,
                qdrant_client=vector_db.client,
                tenant_id=search_tenant_id,
                include_summary=include_summary_chain,
                include_similar_tickets=include_similar_tickets,
                include_kb_docs=include_kb_docs,
                top_k_tickets=top_k_tickets,
                top_k_kb=top_k_kb
            )
            
            sequential_execution_time = time.time() - sequential_start_time
            logger.info(f"순차 실행 완료 (ticket_id: {ticket_id}, 총 실행시간: {sequential_execution_time:.2f}초)")
            
            # 체인 결과를 기존 형식으로 변환
            results = []
            task_names_ordered = []
            
            # chain_results 안전성 검증 강화
            if chain_results is None:
                logger.error("chain_results가 None입니다. 기본값으로 응답 생성합니다.")
                chain_results = {}
            elif not isinstance(chain_results, dict):
                logger.error(f"chain_results가 예상 형식이 아닙니다 (타입: {type(chain_results)}). 기본값으로 응답 생성합니다.")
                chain_results = {}
            
            # 요약 결과 처리 (순차 실행 결과 구조에 맞게 수정)
            if cached_summary is not None:
                ticket_summary = cached_summary
            elif include_summary and 'summary' in chain_results:
                summary_result = chain_results.get('summary', {})
                if summary_result is not None and summary_result.get('success', False):
                    # 순차 실행에서는 result가 아닌 summary 키에 직접 데이터가 있음
                    summary_data = summary_result.get('summary', {})
                    if summary_data:  # summary_data가 None이 아닌지 확인
                        summary = TicketSummaryContent(
                            ticket_summary=summary_data.get('summary', '요약 생성에 실패했습니다.'),
                            key_points=summary_data.get('key_points', []),
                            sentiment=summary_data.get('sentiment', '중립적'),
                            priority_recommendation=summary_data.get('priority_recommendation', '보통'),
                            urgency_level=summary_data.get('urgency_level', '보통')
                        )
                        # 캐시에 async 방식으로 저장
                        await ticket_summary_cache.set(ticket_id, summary)
                        ticket_summary = summary
                    else:
                        logger.warning("summary_data가 비어있습니다. 기본 요약을 생성합니다.")
                        summary = TicketSummaryContent(
                            ticket_summary=f"티켓 제목: {ticket_title or '제목 없음'}",
                            key_points=["요약 데이터 없음", "수동 검토 필요"],
                            sentiment="중립적",
                            priority_recommendation="보통",
                            urgency_level="보통"
                        )
                        ticket_summary = summary
                else:
                    error_msg = summary_result.get('error', '알 수 없는 오류') if summary_result is not None else 'summary_result is None'
                    logger.warning(f"요약 생성 실패: {error_msg}")
                    summary = TicketSummaryContent(
                        ticket_summary=f"오류로 인해 요약 생성에 실패했습니다. 티켓 제목: {ticket_title or '제목 없음'}",
                        key_points=["요약 생성 오류", "수동 검토 필요"],
                        sentiment="중립적",
                        priority_recommendation="보통",
                        urgency_level="보통"
                    )
                    ticket_summary = summary

                results.append((summary, summary_result.get('execution_time', 0) if summary_result is not None else 0))
                task_names_ordered.append('summary')
                task_times['summary'] = summary_result.get('execution_time', 0) if summary_result is not None else 0
            
            # 통합 검색 결과 처리 (안전성 대폭 향상)
            if 'unified_search' in chain_results:
                unified_result = chain_results.get('unified_search')
                
                # unified_result 안전성 검증 강화
                if unified_result is None:
                    logger.warning("unified_result가 None입니다. 빈 검색 결과로 처리합니다.")
                    unified_result = {"success": False, "similar_tickets": [], "kb_documents": [], "execution_time": 0}
                elif not isinstance(unified_result, dict):
                    logger.warning(f"unified_result가 딕셔너리가 아닙니다 (타입: {type(unified_result)}). 빈 검색 결과로 처리합니다.")
                    unified_result = {"success": False, "similar_tickets": [], "kb_documents": [], "execution_time": 0}
                
                if unified_result.get('success', False):
                    # 유사 티켓 결과 추출 (안전성 향상)
                    if include_similar_tickets:
                        similar_tickets_data = unified_result.get('similar_tickets', [])
                        similar_tickets = similar_tickets_data if isinstance(similar_tickets_data, list) else []
                        
                        # 🌍 에이전트 언어 기반 유사 티켓 요약 현지화
                        if similar_tickets and agent_language:
                            try:
                                localized_tickets = []
                                agent_profile = {"language": agent_language}
                                
                                for ticket in similar_tickets:
                                    # SimilarTicketItem 객체인 경우 처리
                                    if hasattr(ticket, 'issue') and ticket.issue:
                                        localized_issue = await get_agent_localized_summary(
                                            ticket_id=str(ticket.id),
                                            original_summary=ticket.issue,
                                            agent_profile=agent_profile
                                        )
                                        ticket.issue = localized_issue
                                    
                                    if hasattr(ticket, 'solution') and ticket.solution:
                                        localized_solution = await get_agent_localized_summary(
                                            ticket_id=str(ticket.id),
                                            original_summary=ticket.solution,
                                            agent_profile=agent_profile
                                        )
                                        ticket.solution = localized_solution
                                    
                                    if hasattr(ticket, 'ticket_summary') and ticket.ticket_summary:
                                        localized_summary = await get_agent_localized_summary(
                                            ticket_id=str(ticket.id),
                                            original_summary=ticket.ticket_summary,
                                            agent_profile=agent_profile
                                        )
                                        ticket.ticket_summary = localized_summary
                                    
                                    localized_tickets.append(ticket)
                                
                                similar_tickets = localized_tickets
                                logger.debug(f"유사 티켓 {len(similar_tickets)}개 현지화 완료 (언어: {agent_language})")
                                
                            except Exception as e:
                                logger.warning(f"유사 티켓 현지화 중 오류 (계속 진행): {e}")
                                # 오류 발생 시 원본 유지
                        
                        task_times['similar_tickets'] = unified_result.get('execution_time', 0)
                        task_names_ordered.append('similar_tickets')
                    
                    # KB 문서 결과 추출 (안전성 향상)
                    if include_kb_docs:
                        kb_documents_data = unified_result.get('kb_documents', [])
                        kb_documents = kb_documents_data if isinstance(kb_documents_data, list) else []
                        task_times['kb_documents'] = unified_result.get('execution_time', 0)
                        task_names_ordered.append('kb_documents')
                    
                    # 통합 검색 성능 정보 로깅
                    cache_used = unified_result.get('cache_used', False)
                    performance_metrics = unified_result.get('search_performance', {})
                    logger.info(f"통합 검색 완료 - 캐시 사용: {cache_used}, 성능: {performance_metrics}")
                    
                else:
                    # 통합 검색 실패 시 빈 결과로 폴백
                    error_msg = unified_result.get('error', 'Unknown error')
                    logger.warning(f"통합 검색 실패: {error_msg}")
                    if include_similar_tickets:
                        similar_tickets = []
                        task_times['similar_tickets'] = unified_result.get('execution_time', 0)
                        task_names_ordered.append('similar_tickets')
                    if include_kb_docs:
                        kb_documents = []
                        task_times['kb_documents'] = unified_result.get('execution_time', 0)
                        task_names_ordered.append('kb_documents')
            
            else:
                # 레거시 방식으로 개별 결과 처리 (통합 검색이 비활성화된 경우)
                # 유사 티켓 결과 처리  
                if include_similar_tickets and 'similar_tickets' in chain_results:
                    similar_result = chain_results['similar_tickets']
                    if similar_result.get('success', False):
                        similar_tickets = similar_result.get('result', [])
                    else:
                        similar_tickets = []
                        logger.warning(f"유사 티켓 검색 실패: {similar_result.get('error', 'Unknown error')}")
                    
                    results.append((similar_tickets, similar_result.get('execution_time', 0)))
                    task_names_ordered.append('similar_tickets')
                    task_times['similar_tickets'] = similar_result.get('execution_time', 0)
                
                # 지식베이스 문서 결과 처리
                if include_kb_docs and 'kb_documents' in chain_results:
                    kb_result = chain_results['kb_documents']
                    if kb_result.get('success', False):
                        kb_documents = kb_result.get('result', [])
                    else:
                        kb_documents = []
                        logger.warning(f"지식베이스 문서 검색 실패: {kb_result.get('error', 'Unknown error')}")
                    
                    results.append((kb_documents, kb_result.get('execution_time', 0)))
                    task_names_ordered.append('kb_documents')
                    task_times['kb_documents'] = kb_result.get('execution_time', 0)
            
            # task_names를 정렬된 순서로 업데이트
            task_names = task_names_ordered
            
        except Exception as e:
            logger.error(f"순차 실행 중 예상치 못한 오류 발생: {str(e)}")
            logger.warning("순차 실행 실패, 기본값으로 응답 생성")
            
            # 기본값 설정
            if include_summary and not ticket_summary:
                ticket_summary = TicketSummaryContent(
                    ticket_summary=f"티켓 제목: {ticket_title or '제목 없음'}",
                    key_points=["순차 실행 처리 오류로 인한 기본 요약"],
                    sentiment="중립적",
                    priority_recommendation="보통",
                    urgency_level="보통"
                )
            
            if include_similar_tickets and not similar_tickets:
                similar_tickets = []
                
            if include_kb_docs and not kb_documents:
                kb_documents = []
            
            task_names = []
            if include_summary:
                task_names.append('summary')
            if include_similar_tickets:
                task_names.append('similar_tickets')
            if include_kb_docs:
                task_names.append('kb_documents')
        
        # 전체 요청 처리 총 소요 시간 계산
        total_time = time.time() - context_start_time
        
        # 성능 향상 효과 계산 및 로깅
        if task_times:
            total_individual_time = sum(task_times.values())
            if total_individual_time > 0:
                improvement_ratio = total_individual_time / total_time
                time_saved = total_individual_time - total_time
                logger.info(f"🚀 병렬 처리 효과 - 총 시간: {total_time:.3f}초 ({improvement_ratio:.1f}배 빠름, {time_saved:.3f}초 단축)")
            else:
                logger.info(f"⏱️ 총 소요 시간: {total_time:.3f}초")
        
        # 결과 구성
        # 티켓 메타데이터에 id가 없으면 ticket_id로 추가
        if isinstance(ticket_metadata, dict) and "id" not in ticket_metadata:
            ticket_metadata["id"] = ticket_id
            
        result = InitResponse(
            ticket_id=ticket_id,
            tenant_id=tenant_id,  # tenant_id 필드 추가
            platform=platform,   # platform 필드 추가
            ticket_data=ticket_metadata,
            ticket_summary=ticket_summary,  # 일관된 필드명 사용
            similar_tickets=similar_tickets,
            kb_documents=kb_documents,
            context_id=context_id,
            metadata={
                "duration_ms": int(total_time * 1000),
                "similar_tickets_count": len(similar_tickets),
                "kb_docs_count": len(kb_documents),
                "task_times": {k: round(v, 3) for k, v in task_times.items()}  # 각 작업별 시간 포함
            }
        )
        
        # 결과 캐싱 (async 방식으로 변경)
        context_data = {
            "ticket_id": ticket_id,
            "tenant_id": search_tenant_id,
            "ticket_data": ticket_metadata,
            "similar_tickets": similar_tickets,
            "kb_documents": kb_documents,
            "created_at": time.time()
        }
        try:
            await ticket_context_cache.set(context_id, context_data)
        except Exception as e:
            logger.warning(f"컨텍스트 캐시 저장 중 오류: {e}")
        
        
        return result
        
    except HTTPException as http_exc:
        raise http_exc
    except Exception as e:
        logger.error(f"전체 초기화 프로세스 중 오류 발생: {str(e)}")
        raise HTTPException(status_code=500, detail=f"초기화 중 오류가 발생했습니다: {str(e)}")
