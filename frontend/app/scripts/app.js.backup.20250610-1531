let client; // Global client variable

app
  .initialized()
  .then((c) => {
    client = c;
    console.log("✅ 앱 초기화 완료");
    console.log("📱 클라이언트 객체:", client);
    
    // ① 상단 네비게이션 앱 아이콘 클릭 시 처리
    client.events.on("app.activated", async () => {
      try {
        const ctx = await client.instance.context();

        // 디버깅: 실제 location 값 확인
        console.log("앱 활성화 - 컨텍스트:", ctx);
        console.log("현재 location:", ctx.location);

        // 상단 네비게이션에서의 동작: 백엔드 데이터 로드 후 모달 표시
        if (ctx.location === "ticket_top_navigation") {
          console.log(
            "상단 네비게이션 아이콘 클릭 → 백엔드 데이터 로드 후 모달 표시"
          );

          // 1단계: 백엔드에서 데이터 로드 (DOM 접근 없이)
          //await loadTicketDataFromBackend();

          // 2단계: 모달 표시
          await showModal();
        } else {
          // 예상치 못한 위치에서의 호출
          console.warn("예상치 못한 위치에서 앱 활성화:", ctx.location);
          //await loadTicketDataFromBackend();
          // Load ticket details for other locations
          await loadTicketDetails(client);
          setupTabEvents(client);
          setupSearchButton(client);
        }
      } catch (err) {
        console.error("onAppActivated 오류", err);
      }
    });

    // ② 모달이 열린 후 DOM 요소에 데이터 렌더링
    client.events.on("template.render", () => {
      try {
        console.log("🎭 모달 템플릿 렌더링 완료 - DOM 초기화 시작");

        // DOM이 완전히 로드되도록 짧은 지연 후 초기화
        setTimeout(async () => {
          await loadTicketDetails(client);
          setupTabEvents(client);
          setupSearchButton(client);
        }, 100);
      } catch (err) {
        console.error("template.render 오류", err);
      }
    });
  })
  .catch((error) => {
    console.error("앱 초기화 실패:", error);
  });
        console.error("template.render 이벤트 처리 오류", err);
      }
    });

    // ③ 티켓 속성 업데이트 이벤트 리스너
    client.events.on("ticket.propertiesUpdated", function () {
      // 티켓 속성 업데이트 시 백엔드 데이터 새로고침
      console.log("🔄 티켓 속성 업데이트됨 - 데이터 새로고침");
      loadTicketDataFromBackend();
    });
  })
  .catch((err) => console.error("SDK 초기화 실패", err));

/**
 * 탭 전환 기능 초기화 (각 탭별 최초 1회만 렌더링)
 */
function initTabSwitching() {
  const tabs = document.querySelectorAll(".tab");
  const tabContents = document.querySelectorAll(".tab-content");

  tabs.forEach((tab) => {
    tab.addEventListener("click", function () {
      const tabId = this.getAttribute("data-tab");

      // Remove active class from all tabs and tab contents
      tabs.forEach((tab) => tab.classList.remove("active"));
      tabContents.forEach((content) => content.classList.remove("active"));

      // Add active class to clicked tab and corresponding content
      this.classList.add("active");
      const targetContent = document.getElementById(tabId);
      if (targetContent) {
        targetContent.classList.add("active");
      }

      // Handle tab-specific actions using only cached data (render approach)
      if (tabId === "similar-tickets") {
        // 캐시된 데이터만 사용하는 render 방식
        if (
          window.ticketInitData &&
          window.ticketInitData.similar_tickets &&
          window.ticketInitData.similar_tickets.length > 0
        ) {
          console.log("📋 캐시된 유사 티켓 데이터 사용");
          updateSimilarTicketsFromCache(window.ticketInitData.similar_tickets);
        } else {
          console.log("🔍 유사 티켓 데이터 없음");
          const container = document.getElementById("similar-tickets");
          if (container) {
            container.innerHTML = "<p>유사한 티켓을 찾을 수 없습니다.</p>";
          }
        }
      } else if (tabId === "suggested-solutions") {
        // 캐시된 지식베이스 데이터만 사용하는 render 방식
        if (
          window.ticketInitData &&
          window.ticketInitData.kb_docs &&
          window.ticketInitData.kb_docs.length > 0
        ) {
          console.log("📚 캐시된 지식베이스 데이터 사용");
          updateKnowledgeBaseFromCache(window.ticketInitData.kb_docs);
        } else {
          console.log("🔍 추천 솔루션 데이터 없음");
          const container = document.getElementById("suggested-solutions");
          if (container) {
            container.innerHTML = "<p>관련 문서를 찾을 수 없습니다.</p>";
          }
        }
      }
    });
  });

  // Initialize active tab on page load using only cached data
  const activeTab = document.querySelector(".tab.active");
  if (activeTab) {
    const tabId = activeTab.getAttribute("data-tab");

    if (tabId === "similar-tickets") {
      // 캐시된 데이터만 사용하는 render 방식으로 초기화
      if (
        window.ticketInitData &&
        window.ticketInitData.similar_tickets &&
        window.ticketInitData.similar_tickets.length > 0
      ) {
        updateSimilarTicketsFromCache(window.ticketInitData.similar_tickets);
      } else {
        const container = document.getElementById("similar-tickets");
        if (container) {
          container.innerHTML =
            "<p>비슷한 티켓 데이터가 없습니다. 데이터 로딩을 기다려주세요.</p>";
        }
      }
    } else if (tabId === "suggested-solutions") {
      // 캐시된 데이터만 사용하는 render 방식으로 초기화
      if (
        window.ticketInitData &&
        window.ticketInitData.kb_docs &&
        window.ticketInitData.kb_docs.length > 0
      ) {
        updateKnowledgeBaseFromCache(window.ticketInitData.kb_docs);
      } else {
        const container = document.getElementById("suggested-solutions");
        if (container) {
          container.innerHTML =
            "<p>제안된 솔루션 데이터가 없습니다. 데이터 로딩을 기다려주세요.</p>";
        }
      }
    }
  }
}

/**
 * 필터 선택 기능 초기화
 */
function initFilterSelection() {
  const filters = document.querySelectorAll(".filter");
  filters.forEach((filter) => {
    filter.addEventListener("click", function () {
      this.classList.toggle("active");
    });
  });
}

/**
 * 공통 모달 트리거 함수
 */
async function showModal() {
  try {
    console.log("🚀 모달 열기 시작");

    // 컨텍스트 정보 가져오기
    const context = await client.instance.context();
    console.log("📍 컨텍스트 정보:", context);

    const data = await client.data.get("ticket");
    const ticket = data.ticket;
    console.log("📋 티켓 데이터 가져옴:", ticket.id);

    // 모달 생성 시 instanceId 포함
    const modalConfig = {
      title: "Copilot Canvas",
      template: "index.html",
      data: {
        showAiTab: false,
        ticket,
        context: context, // 컨텍스트 정보 추가
      },
      noBackdrop: true,
      size: {
        width: "800px",
        height: "600px",
      },
    };

    console.log("🔧 모달 설정:", modalConfig);
    await client.interface.trigger("showModal", modalConfig);
    console.log("✅ 모달 열림 완료");
  } catch (error) {
    console.error("❌ 모달 오류:", error);
    console.error("❌ 모달 오류 스택:", error.stack);

    // 폴백: 간단한 모달로 재시도
    try {
      console.log("🔄 폴백 모달 시도");
      await client.interface.trigger("showModal", {
        title: "Copilot Canvas",
        template: "index.html",
      });
    } catch (fallbackError) {
      console.error("❌ 폴백 모달도 실패:", fallbackError);
    }
  }
}

/**
 * 코파일럿 AI 응답 모달 트리거 함수
 */
async function showCopilotModal() {
  try {
    const data = await client.data.get("ticket");
    const ticket = data.ticket;
    await client.interface.trigger("showModal", {
      title: "Copilot Canvas",
      template: "modal.html",
      data: { showAiTab: true, ticket },
      noBackdrop: true,
      size: {
        width: "800px",
        height: "600px",
      },
    });
    console.log("Copilot Modal 열림");
  } catch (error) {
    console.error("Copilot Modal 오류", error);
  }
}

/**
 * 모든 DOM 이벤트 리스너를 초기화하는 함수
 */
function initEventListeners() {
  // 탭 전환 기능 초기화
  initTabSwitching();

  // 필터 선택 기능 초기화
  initFilterSelection();

  // 검색 버튼 클릭 이벤트
  const searchBtn = document.querySelector(".search-btn");
  if (searchBtn) {
    searchBtn.addEventListener("click", async function () {
      try {
        await showCopilotModal();
      } catch (error) {
        console.error("검색 버튼 오류:", error);
      }
    });
  }

  // Copilot 검색 버튼 클릭 이벤트
  const copilotSearchBtn = document.getElementById("copilot-search-btn");
  if (copilotSearchBtn) {
    copilotSearchBtn.addEventListener("click", async function () {
      try {
        await performCopilotSearch();
      } catch (error) {
        console.error("Copilot 검색 오류:", error);
      }
    });
  }

  // Copilot 입력창 엔터키 이벤트
  const copilotInput = document.getElementById("copilot-input");
  if (copilotInput) {
    copilotInput.addEventListener("keypress", async function (e) {
      if (e.key === "Enter") {
        try {
          await performCopilotSearch();
        } catch (error) {
          console.error("Copilot 검색 오류:", error);
        }
      }
    });
  }

  // 상세 보기 버튼 클릭 이벤트
  const viewDetailsBtn = document.getElementById("view-details-btn");
  if (viewDetailsBtn) {
    viewDetailsBtn.addEventListener("click", async function () {
      try {
        console.log("🔍 상세 보기 버튼 클릭됨");
        await showModal();
      } catch (error) {
        console.error("❌ 상세 보기 버튼 오류:", error);
      }
    });
  } else {
    console.warn("⚠️ view-details-btn 요소를 찾을 수 없습니다.");
  }
}

/**
 * 유사 티켓 데이터를 캐시에서 가져와 UI에 표시 (최초 1회만 렌더링)
 */
let isSimilarTicketsRendered = false; // 이미 렌더링 여부 플래그
function renderSimilarTicketsFromCache() {
  try {
    // 이미 렌더링된 경우 재렌더링 방지
    if (isSimilarTicketsRendered) return;
    // 로딩 상태 표시
    document.getElementById("similar-tickets").innerHTML =
      "<p>유사 티켓을 불러오는 중입니다...</p>";
    // 캐시 데이터 확인
    if (window.ticketInitData && window.ticketInitData.similar_tickets) {
      console.log("📋 캐시된 유사 티켓 데이터 사용");
      const similarTickets = window.ticketInitData.similar_tickets;
      if (similarTickets.length > 0) {
        // updateSimilarTicketsFromCache 함수가 있다면 활용
        if (typeof updateSimilarTicketsFromCache === "function") {
          updateSimilarTicketsFromCache(similarTickets);
        } else {
          // 직접 테이블 렌더링 (예시)
          let tableHtml = `<fw-data-table id="similar-tickets-table" label="유사 티켓"></fw-data-table>`;
          document.getElementById("similar-tickets").innerHTML = tableHtml;
          const table = document.getElementById("similar-tickets-table");
          const columns = [
            { key: "id", text: "ID" },
            { key: "subject", text: "제목" },
            { key: "status", text: "상태" },
            { key: "priority", text: "우선순위" },
            { key: "score", text: "유사도" },
          ];
          const rows = similarTickets.map((t) => ({
            id: t.id?.toString() || "-",
            subject: t.subject || "-",
            status: t.status || "-",
            priority: t.priority || "-",
            score: t.score ? `${Math.round(t.score * 100)}%` : "-",
          }));
          table.columns = columns;
          table.rows = rows;
        }
        isSimilarTicketsRendered = true; // 렌더링 완료 플래그 설정
      } else {
        document.getElementById("similar-tickets").innerHTML =
          "<p>유사 티켓이 없습니다.</p>";
      }
    } else {
      document.getElementById("similar-tickets").innerHTML =
        "<p>유사 티켓 데이터를 불러올 수 없습니다. 새로고침 해주세요.</p>";
    }
  } catch (error) {
    document.getElementById("similar-tickets").innerHTML =
      "<p>유사 티켓 표시 중 오류가 발생했습니다.</p>";
    console.error("유사 티켓 렌더링 오류:", error);
  }
}

/**
 * 추천 솔루션(지식베이스) 데이터를 캐시에서 가져와 UI에 표시 (최초 1회만 렌더링)
 */
let isSuggestedSolutionsRendered = false; // 이미 렌더링 여부 플래그
function renderSuggestedSolutionsFromCache() {
  try {
    if (isSuggestedSolutionsRendered) return;

    console.log("📚 추천 솔루션 렌더링 시작");
    document.getElementById("suggested-solutions").innerHTML =
      "<p>추천 솔루션을 불러오는 중입니다...</p>";

    if (window.ticketInitData && window.ticketInitData.kb_docs) {
      console.log("📚 캐시된 추천 솔루션 데이터 사용");
      const kbDocs = window.ticketInitData.kb_docs;

      if (Array.isArray(kbDocs) && kbDocs.length > 0) {
        // updateSuggestedSolutionsFromCache 함수 호출하여 실제 렌더링 처리
        updateSuggestedSolutionsFromCache();
        isSuggestedSolutionsRendered = true;
        console.log("✅ 추천 솔루션 렌더링 완료");
      } else {
        document.getElementById("suggested-solutions").innerHTML =
          "<p>추천 솔루션이 없습니다.</p>";
        console.log("❌ 추천 솔루션 데이터 없음");
      }
    } else {
      document.getElementById("suggested-solutions").innerHTML =
        "<p>추천 솔루션 데이터를 불러올 수 없습니다. 새로고침 해주세요.</p>";
      console.log("❌ 추천 솔루션 캐시 데이터 없음");
    }
  } catch (error) {
    document.getElementById("suggested-solutions").innerHTML =
      "<p>추천 솔루션 표시 중 오류가 발생했습니다.</p>";
    console.error("추천 솔루션 렌더링 오류:", error);
  }
}

/**
 * Handle attachment download when the download button is clicked
 * @param {Event} event - Click event
 */
async function handleAttachmentDownload(event) {
  try {
    // Show loading state
    const downloadButton = event.currentTarget;
    const attachmentId = downloadButton.getAttribute("data-attachment-id");

    // Disable the button and show loading state
    downloadButton.loading = true;

    // Get attachment details using Data API
    const attachmentData = await client.data.get("attachment", {
      id: attachmentId,
    });
    const attachment = attachmentData.attachment;

    if (attachment && attachment.attachment_url) {
      // Create a temporary anchor element to trigger download
      const downloadLink = document.createElement("a");
      downloadLink.href = attachment.attachment_url;
      downloadLink.download = attachment.name || "attachment";
      downloadLink.target = "_blank";
      downloadLink.click();

      // Show success notification
      client.interface.trigger("showNotify", {
        type: "success",
        message: `Downloading ${attachment.name}`,
      });
    } else {
      // Show error notification if attachment URL is not available
      client.interface.trigger("showNotify", {
        type: "danger",
        message: "Failed to get attachment download URL",
      });
    }
  } catch (error) {
    console.error("Error downloading attachment:", error);
    client.interface.trigger("showNotify", {
      type: "danger",
      message: "Failed to download attachment. Please try again.",
    });
  } finally {
    // Reset button state after download attempt
    event.currentTarget.loading = false;
  }
}

/**
 * 페이지 로드 시 백엔드에서 티켓 데이터를 미리 로드하는 함수 (DOM 접근 없이)
 * 데이터는 window.ticketInitData에 저장되어 나중에 모달에서 사용됨
 *
 * 이제 백그라운드로 실행되어 7-8초 로딩 시간을 0초로 단축합니다.
 */
async function loadTicketDataFromBackend() {
  try {
    console.log("🚀 백그라운드 데이터 로드 시작 (즉시 반환하여 로딩 시간 0초)");

    // 기존 데이터 초기화
    window.ticketInitData = {
      isLoading: true,
      ticket_id: null,
    };

    // 티켓 ID 추출
    const data = await client.data.get("ticket");
    const ticketId = data.ticket.id;
    window.ticketInitData.ticket_id = ticketId;

    // Freshdesk 도메인 추출 (여러 방법 시도)
    let freshdeskDomain = null;

    try {
      // 1. iparams에서 시도
      const iparams = await client.iparams.get();
      freshdeskDomain = iparams.freshdesk_domain || iparams.domain;
    } catch (e) {
      console.warn("iparams에서 도메인 추출 실패:", e);
    }

    // 2. 현재 브라우저 URL에서 추출
    if (!freshdeskDomain) {
      try {
        const currentUrl = window.location.href;
        const urlMatch = currentUrl.match(/https?:\/\/([^.]+)\.freshdesk\.com/);
        if (urlMatch) {
          freshdeskDomain = urlMatch[1] + ".freshdesk.com";
        }
      } catch (e) {
        console.warn("URL에서 도메인 추출 실패:", e);
      }
    }

    // 3. 컨텍스트에서 추출 시도
    if (!freshdeskDomain) {
      try {
        const context = await client.instance.context();
        if (context && context.data && context.data.domain) {
          freshdeskDomain = context.data.domain;
        }
      } catch (e) {
        console.warn("컨텍스트에서 도메인 추출 실패:", e);
      }
    }

    console.log(`📋 티켓 ID: ${ticketId}`);
    console.log(`🔑 Freshdesk 도메인: ${freshdeskDomain || "UNKNOWN"}`);

    // 백그라운드에서 비동기로 데이터 로드 (Promise를 기다리지 않음)
    loadDataInBackground(ticketId, freshdeskDomain);

    // 즉시 반환하여 모달이 바로 열리도록 함
    return window.ticketInitData;
  } catch (err) {
    console.error("백엔드 데이터 로드 오류", err);
    // 에러가 발생해도 빈 객체로 초기화하여 모달은 열리도록 함
    window.ticketInitData = {
      isLoading: false,
      error: err.message,
    };
    return window.ticketInitData;
  }
}

/**
 * 백그라운드에서 실제 데이터를 로드하는 함수
 * UI를 블록하지 않고 비동기로 실행됩니다.
 */
async function loadDataInBackground(ticketId, freshdeskDomain = null) {
  try {
    console.log("⏱️ 백그라운드 로딩 시작 - UI는 즉시 사용 가능");

    // 도메인이 없으면 백엔드 호출 건너뛰기
    if (!freshdeskDomain) {
      console.warn("⚠️ Freshdesk 도메인이 없어 백엔드 호출을 건너뜁니다");
      window.ticketInitData.isLoading = false;
      window.ticketInitData.error = "No Freshdesk domain available";
      return;
    }

    // Freshdesk client.request API를 사용하여 백엔드 호출
    const response = await client.request.invoke("backendApi", {
      context: {
        path: `/init/${ticketId}`,
      },
      headers: {
        "X-Freshdesk-Domain": freshdeskDomain,
        "Content-Type": "application/json",
      },
    });

    console.log("✅ 백그라운드 응답 수신:", response);

    // 응답 데이터 처리
    if (response && response.response) {
      const responseData = response.response;

      // 데이터를 글로벌 캐시에 저장
      window.ticketInitData = {
        isLoading: false,
        ticket_id: ticketId,
        summary: responseData.ticket_summary || responseData.summary,
        similar_tickets: responseData.similar_tickets || [],
        kb_docs: responseData.kb_documents || responseData.kb_docs || [],
        context_id: responseData.context_id,
        ticket_metadata:
          responseData.ticket_metadata || responseData.ticket || null,
        loadedAt: new Date().toISOString(),
      };

      console.log("✅ 백그라운드 데이터 로드 완료:", window.ticketInitData);

      // 이미 모달이 열려있다면 데이터 자동 업데이트
      updateUIIfModalOpen();
    } else {
      console.warn("⚠️ 백엔드에서 유효한 응답을 받지 못했습니다");
      window.ticketInitData.isLoading = false;
      window.ticketInitData.error = "Invalid response from backend";
    }
  } catch (err) {
    console.error("❌ 백그라운드 API 호출 오류:", err);
    window.ticketInitData.isLoading = false;
    window.ticketInitData.error = err.message;

    // 백엔드 연결 실패 시 Freshdesk에서 기본 정보 가져오기
    try {
      console.log("🔄 백엔드 실패 - Freshdesk 기본 데이터로 폴백");
      const data = await client.data.get("ticket");
      const ticket = data.ticket;

      window.ticketInitData.ticket_metadata = {
        id: ticket.id,
        subject: ticket.subject,
        description: ticket.description_text || ticket.description,
        status: ticket.status,
        priority: ticket.priority,
        requester_id: ticket.requester_id,
        created_at: ticket.created_at,
        updated_at: ticket.updated_at,
      };

      console.log("✅ Freshdesk 폴백 데이터 로드 완료");
      updateUIIfModalOpen();
    } catch (fallbackError) {
      console.error("❌ Freshdesk 폴백도 실패:", fallbackError);
    }
  }
}

/**
 * 모달이 이미 열려있는 경우 백그라운드 로딩 완료 시 UI 자동 업데이트
 */
function updateUIIfModalOpen() {
  try {
    // DOM 요소가 존재하는지 확인 (모달이 열려있는지 체크)
    const summaryEl = document.getElementById("summary");
    const similarTicketsEl = document.getElementById("similar-tickets");
    const suggestedSolutionsEl = document.getElementById("suggested-solutions");
    const ticketSummaryCard = document.querySelector(".ticket-summary-card");

    if (
      summaryEl ||
      similarTicketsEl ||
      suggestedSolutionsEl ||
      ticketSummaryCard
    ) {
      console.log(
        "🔄 모달이 열려있음 - 백그라운드 로딩 완료로 UI 자동 업데이트"
      );

      // 새로운 UI 구조에 맞게 전체 업데이트
      updateUIWithInitData(window.ticketInitData);

      // 기존 호환성을 위한 개별 업데이트
      if (window.ticketInitData.summary && summaryEl) {
        renderSummaryFromCache();
      }
      if (window.ticketInitData.similar_tickets && similarTicketsEl) {
        updateSimilarTicketsFromCache(window.ticketInitData.similar_tickets);
      }
      if (window.ticketInitData.kb_docs && suggestedSolutionsEl) {
        updateKnowledgeBaseFromCache(window.ticketInitData.kb_docs);
      }
    }
  } catch (error) {
    console.warn("UI 자동 업데이트 중 오류:", error);
  }
}

/**
 * 모달이 열린 후 DOM 요소에 데이터를 렌더링하는 함수
 * 백그라운드 로딩 상태를 확인하고, 필요시 SSE 스트리밍을 활용합니다.
 */
async function initializeTicketWithBackend() {
  try {
    console.log("🔄 모달 내 티켓 데이터 초기화 시작");

    // DOM 요소 존재 확인 (안전성 체크)
    const summaryEl = document.getElementById("summary");
    const similarTicketsEl = document.getElementById("similar-tickets");
    const suggestedSolutionsEl = document.getElementById("suggested-solutions");

    if (!summaryEl || !similarTicketsEl || !suggestedSolutionsEl) {
      console.warn(
        "⚠️ DOM 요소가 아직 존재하지 않음 - 모달이 완전히 로드되지 않았을 수 있음"
      );
      // 짧은 지연 후 재시도
      setTimeout(() => initializeTicketWithBackend(), 500);
      return;
    }

    // 백그라운드 로딩 상태 확인
    if (
      window.ticketInitData &&
      !window.ticketInitData.isLoading &&
      window.ticketInitData.summary
    ) {
      // 이미 로드 완료된 데이터가 있으면 즉시 렌더링
      console.log("⚡ 백그라운드 로딩 완료됨 - 즉시 렌더링");
      renderCompletedData();
      return;
    }

    if (window.ticketInitData && window.ticketInitData.isLoading) {
      // 백그라운드 로딩 중인 경우 로딩 상태 표시
      console.log("⏳ 백그라운드 로딩 중 - 로딩 상태 표시 후 완료 대기");
      showLoadingState();

      // 백그라운드 로딩 완료 대기 (폴링 방식)
      waitForBackgroundLoading();
      return;
    }

    // 데이터가 없거나 에러가 있는 경우 직접 API 호출
    console.log("🔄 데이터 없음 - 직접 API 호출");
    await loadDataDirectly();
  } catch (error) {
    console.error("모달 티켓 초기화 오류", error);
    showErrorState();
  }
}

/**
 * 이미 로드 완료된 데이터를 즉시 렌더링
 */
function renderCompletedData() {
  try {
    // 새로운 UI 구조에 맞게 전체 데이터 업데이트
    updateUIWithInitData(window.ticketInitData);

    // 기존 호환성을 위한 로직 (필요한 경우)
    if (window.ticketInitData.summary) {
      renderSummaryFromCache();
    }
    if (
      window.ticketInitData.similar_tickets &&
      window.ticketInitData.similar_tickets.length > 0
    ) {
      updateSimilarTicketsFromCache(window.ticketInitData.similar_tickets);
    }
    if (
      window.ticketInitData.kb_docs &&
      window.ticketInitData.kb_docs.length > 0
    ) {
      updateKnowledgeBaseFromCache(window.ticketInitData.kb_docs);
    }
    console.log("✅ 모든 데이터 즉시 렌더링 완료");
  } catch (error) {
    console.error("데이터 렌더링 중 오류:", error);
  }
}

/**
 * 로딩 상태 UI 표시
 */
function showLoadingState() {
  const summaryEl = document.getElementById("summary");
  const similarTicketsEl = document.getElementById("similar-tickets");
  const suggestedSolutionsEl = document.getElementById("suggested-solutions");

  if (summaryEl) {
    summaryEl.innerHTML = `
      <div class="loading-container">
        <div class="loading-spinner"></div>
        <p>🔄 티켓 요약을 생성 중입니다...</p>
        <small>백엔드에서 AI가 분석 중입니다.</small>
      </div>
    `;
  }

  if (similarTicketsEl) {
    similarTicketsEl.innerHTML = `
      <div class="loading-container">
        <div class="loading-spinner"></div>
        <p>🔍 유사한 티켓을 검색 중입니다...</p>
        <small>과거 티켓들과 비교 분석 중입니다.</small>
      </div>
    `;
  }

  if (suggestedSolutionsEl) {
    suggestedSolutionsEl.innerHTML = `
      <div class="loading-container">
        <div class="loading-spinner"></div>
        <p>💡 관련 솔루션을 찾고 있습니다...</p>
        <small>지식베이스에서 최적의 해답을 검색 중입니다.</small>
      </div>
    `;
  }
}

/**
 * 백그라운드 로딩 완료를 기다리는 함수 (폴링 방식)
 */
function waitForBackgroundLoading() {
  const checkInterval = setInterval(() => {
    if (window.ticketInitData && !window.ticketInitData.isLoading) {
      clearInterval(checkInterval);

      if (window.ticketInitData.error) {
        console.error("백그라운드 로딩 실패:", window.ticketInitData.error);
        showErrorState();
      } else {
        console.log("✅ 백그라운드 로딩 완료 - 데이터 렌더링");
        renderCompletedData();
      }
    }
  }, 500); // 0.5초마다 확인

  // 최대 30초 후 타임아웃
  setTimeout(() => {
    clearInterval(checkInterval);
    if (window.ticketInitData && window.ticketInitData.isLoading) {
      console.warn("⚠️ 백그라운드 로딩 타임아웃");
      showTimeoutState();
    }
  }, 30000);
}

/**
 * 직접 API 호출로 데이터 로드
 */
async function loadDataDirectly() {
  try {
    const data = await client.data.get("ticket");
    const ticketId = data.ticket.id;

    console.log(`📋 직접 API 호출 - 티켓 ID: ${ticketId}`);

    showLoadingState();

    // Freshdesk client.request API를 사용하여 백엔드 호출
    const response = await client.request.invoke("backendApi", {
      context: {
        path: `/init/${ticketId}`,
      },
    });

    console.log("✅ 직접 API 응답 수신:", response);

    if (response && response.response) {
      const responseData = response.response;

      // 데이터를 글로벌 캐시에 저장
      window.ticketInitData = {
        isLoading: false,
        ticket_id: ticketId,
        summary: responseData.ticket_summary || responseData.summary,
        similar_tickets: responseData.similar_tickets || [],
        kb_docs: responseData.kb_documents || responseData.kb_docs || [],
        context_id: responseData.context_id,
      };

      renderCompletedData();
    } else {
      throw new Error("백엔드에서 유효한 응답을 받지 못했습니다");
    }
  } catch (error) {
    console.error("❌ 직접 API 호출 오류:", error);
    showErrorState();
  }
}

/**
 * 에러 상태 UI 표시
 */
function showErrorState() {
  const summaryEl = document.getElementById("summary");
  const similarTicketsEl = document.getElementById("similar-tickets");
  const suggestedSolutionsEl = document.getElementById("suggested-solutions");

  if (summaryEl) {
    summaryEl.innerHTML = `
      <div class="error-container">
        <p>❌ 요약을 불러올 수 없습니다.</p>
        <button onclick="location.reload()" class="retry-btn">새로고침</button>
      </div>
    `;
  }

  if (similarTicketsEl) {
    similarTicketsEl.innerHTML = `
      <div class="error-container">
        <p>❌ 유사 티켓을 불러올 수 없습니다.</p>
        <button onclick="location.reload()" class="retry-btn">새로고침</button>
      </div>
    `;
  }

  if (suggestedSolutionsEl) {
    suggestedSolutionsEl.innerHTML = `
      <div class="error-container">
        <p>❌ 추천 솔루션을 불러올 수 없습니다.</p>
        <button onclick="location.reload()" class="retry-btn">새로고침</button>
      </div>
    `;
  }
}

/**
 * 타임아웃 상태 UI 표시
 */
function showTimeoutState() {
  const summaryEl = document.getElementById("summary");
  const similarTicketsEl = document.getElementById("similar-tickets");
  const suggestedSolutionsEl = document.getElementById("suggested-solutions");

  if (summaryEl) {
    summaryEl.innerHTML = `
      <div class="timeout-container">
        <p>⏰ 로딩 시간이 초과되었습니다.</p>
        <button onclick="location.reload()" class="retry-btn">새로고침</button>
      </div>
    `;
  }

  if (similarTicketsEl) {
    similarTicketsEl.innerHTML = `
      <div class="timeout-container">
        <p>⏰ 로딩 시간이 초과되었습니다.</p>
        <button onclick="location.reload()" class="retry-btn">새로고침</button>
      </div>
    `;
  }

  if (suggestedSolutionsEl) {
    suggestedSolutionsEl.innerHTML = `
      <div class="timeout-container">
        <p>⏰ 로딩 시간이 초과되었습니다.</p>
        <button onclick="location.reload()" class="retry-btn">새로고침</button>
      </div>
    `;
  }
}

/**
 * 요약 데이터를 캐시에서 가져와 UI에 표시
 */
function renderSummaryFromCache() {
  try {
    console.log("📝 요약 데이터 렌더링 시작");
    const summaryDiv = document.getElementById("summary");

    // DOM 안전성 체크
    if (!summaryDiv) {
      console.warn("⚠️ summary DOM 요소를 찾을 수 없음");
      return;
    }

    if (window.ticketInitData && window.ticketInitData.summary) {
      const summaryData = window.ticketInitData.summary;

      // 요약 데이터가 문자열인 경우와 객체인 경우 모두 처리
      let summaryText = "";
      if (typeof summaryData === "string") {
        summaryText = summaryData;
      } else if (summaryData.text || summaryData.summary) {
        summaryText = summaryData.text || summaryData.summary;
      } else {
        summaryText = JSON.stringify(summaryData);
      }

      summaryDiv.innerHTML = `<p>${summaryText}</p>`;
      console.log("✅ 요약 렌더링 완료");
    } else {
      summaryDiv.innerHTML = "<p>요약 데이터를 불러올 수 없습니다.</p>";
      console.log("❌ 요약 데이터 없음");
    }
  } catch (error) {
    console.error("요약 렌더링 오류", error);
    const summaryDiv = document.getElementById("summary");
    if (summaryDiv) {
      summaryDiv.innerHTML = "<p>요약 표시 중 오류가 발생했습니다.</p>";
    }
  }
}

/**
 * 캐시된 유사 티켓 데이터로 UI 업데이트
 */
function updateSimilarTicketsFromCache(similarTickets) {
  try {
    if (similarTickets && similarTickets.length > 0) {
      // 유사 티켓 탭 컨테이너 찾기
      const similarTicketsContainer =
        document.getElementById("similar-tickets");
      if (!similarTicketsContainer) return;

      // 데이터 테이블 HTML 생성
      let tableHtml = `
        <fw-data-table id="cached-similar-tickets-table" label="Similar Tickets (Pre-loaded)">
        </fw-data-table>
      `;

      similarTicketsContainer.innerHTML = tableHtml;

      // 테이블 설정
      const table = document.getElementById("cached-similar-tickets-table");

      // 컬럼 정의
      const columns = [
        { key: "id", text: "Ticket ID" },
        { key: "subject", text: "Subject" },
        { key: "status", text: "Status" },
        { key: "priority", text: "Priority" },
        { key: "similarity_score", text: "Similarity" },
      ];

      // 행 데이터 포맷팅
      const rows = similarTickets.map((ticket) => ({
        id: ticket.id?.toString() || ticket.ticket_id?.toString() || "N/A",
        subject: ticket.subject || ticket.title || "No subject",
        status: ticket.status || "Unknown",
        priority: ticket.priority || "Unknown",
        similarity_score: ticket.similarity_score
          ? `${Math.round(ticket.similarity_score * 100)}%`
          : "N/A",
      }));

      // 테이블 데이터 설정
      table.columns = columns;
      table.rows = rows;

      console.log(
        `✅ 캐시된 유사 티켓 ${similarTickets.length}개 UI 업데이트 완료`
      );
    }
  } catch (error) {
    console.error("❌ 캐시된 유사 티켓 UI 업데이트 실패:", error);
  }
}

/**
 * 캐시된 지식베이스 데이터로 UI 업데이트
 */
function updateKnowledgeBaseFromCache(kbDocs) {
  try {
    if (kbDocs && kbDocs.length > 0) {
      console.log(`📚 캐시된 지식베이스 문서 ${kbDocs.length}개 발견`);

      // 지식베이스 데이터를 suggested-solutions 탭에 표시할 수 있도록 글로벌 변수에 저장
      window.cachedKbDocs = kbDocs;

      // suggested-solutions 탭이 활성화되어 있으면 즉시 표시
      const suggestedSolutionsTab = document.querySelector(
        '.tab[data-tab="suggested-solutions"]'
      );
      if (
        suggestedSolutionsTab &&
        suggestedSolutionsTab.classList.contains("active")
      ) {
        updateSuggestedSolutionsFromCache();
      }
    }
  } catch (error) {
    console.error("❌ 캐시된 지식베이스 UI 업데이트 실패:", error);
  }
}

/**
 * 캐시된 지식베이스로 Suggested Solutions 탭 업데이트
 */
function updateSuggestedSolutionsFromCache() {
  try {
    // 캐시된 데이터에서 직접 가져오기
    const kbDocs = window.ticketInitData && window.ticketInitData.kb_docs;
    const container = document.getElementById("suggested-solutions");

    // DOM 안전성 체크
    if (!container) {
      console.warn("⚠️ suggested-solutions DOM 요소를 찾을 수 없음");
      return;
    }

    if (!kbDocs || !Array.isArray(kbDocs) || kbDocs.length === 0) {
      container.innerHTML = "<p>관련 문서를 찾을 수 없습니다.</p>";
      return;
    }

    let html = '<div class="suggested-solutions-list">';
    html += "<h4>📚 관련 지식베이스 문서 (스트리밍 로드됨)</h4>";

    kbDocs.slice(0, 5).forEach((doc, index) => {
      const title = doc.title || doc.subject || `문서 ${index + 1}`;
      const content =
        doc.content || doc.text || doc.body || "No content available";
      const score = doc.similarity_score
        ? `(유사도: ${Math.round(doc.similarity_score * 100)}%)`
        : "";

      html += `
        <div class="solution-item" style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">
          <h5 style="margin: 0 0 5px 0; color: #333;">${title} ${score}</h5>
          <p style="margin: 0; color: #666; font-size: 14px;">${content.substring(
            0,
            200
          )}${content.length > 200 ? "..." : ""}</p>
        </div>
      `;
    });

    html += "</div>";
    container.innerHTML = html;

    console.log(
      `✅ 캐시된 지식베이스 ${kbDocs.length}개 Suggested Solutions 탭 업데이트 완료`
    );
  } catch (error) {
    console.error("❌ Suggested Solutions 캐시 업데이트 실패:", error);
    const container = document.getElementById("suggested-solutions");
    if (container) {
      container.innerHTML = "<p>추천 솔루션 표시 중 오류가 발생했습니다.</p>";
    }
  }
}

/**
 * Fetch ticket data using Data methods and populate UI
 */
async function getTicketData() {
  try {
    // Get ticket data from the current context
    const data = await client.data.get("ticket");
    const ticket = data.ticket;

    // Populate UI with ticket metadata
    document.getElementById("ticket-problem").textContent =
      ticket.subject || "N/A";
    document.getElementById("ticket-cause").textContent = "Analyzing...";
    document.getElementById("ticket-actions").textContent = "Pending Analysis";
    document.getElementById("ticket-result").textContent = "Pending";
    document.getElementById("ticket-status").textContent =
      ticket.status || "N/A";
    document.getElementById("ticket-priority").textContent =
      ticket.priority || "N/A";

    // Get agent data if assigned
    if (ticket.responder_id) {
      try {
        const agentData = await client.data.get("agent", {
          id: ticket.responder_id,
        });
        document.getElementById("ticket-agent").textContent =
          agentData.agent.name || "Unassigned";
      } catch (error) {
        document.getElementById("ticket-agent").textContent = "Unassigned";
        console.error("Error fetching agent data:", error);
      }
    } else {
      document.getElementById("ticket-agent").textContent = "Unassigned";
    }

    // Get requester data
    try {
      const requesterData = await client.data.get("requester", {
        id: ticket.requester_id,
      });
      document.getElementById("ticket-requester").textContent =
        requesterData.requester.name || "N/A";
    } catch (error) {
      document.getElementById("ticket-requester").textContent = "N/A";
      console.error("Error fetching requester data:", error);
    }

    // Set channel info
    document.getElementById("ticket-channel").textContent =
      ticket.source || "N/A";

    // Set tags
    const tags = ticket.tags || [];
    document.getElementById("ticket-tags").textContent =
      tags.length > 0 ? tags.join(", ") : "No tags";

    // Set attachments
    const attachments = ticket.attachments || [];
    if (attachments.length > 0) {
      const attachmentsContainer = document.getElementById(
        "attachments-container"
      );
      attachmentsContainer.innerHTML = "";

      attachments.forEach((attachment) => {
        const attachmentItem = document.createElement("div");
        attachmentItem.className = "attachment-item";

        const attachmentName = document.createElement("span");
        attachmentName.textContent = attachment.name;

        const downloadBtn = document.createElement("fw-button");
        downloadBtn.color = "secondary";
        downloadBtn.size = "small";
        downloadBtn.setAttribute("data-attachment-id", attachment.id);
        downloadBtn.innerHTML =
          '<fw-icon name="download" size="14" slot="before-label"></fw-icon>Download';

        attachmentItem.appendChild(attachmentName);
        attachmentItem.appendChild(downloadBtn);
        attachmentsContainer.appendChild(attachmentItem);

        // Register click event on the download button
        downloadBtn.addEventListener("click", handleAttachmentDownload);
      });

      document.getElementById("attachments-section").style.display = "block";
    } else {
      document.getElementById("ticket-attachments").textContent = "None";
      document.getElementById("attachments-section").style.display = "none";
    }
  } catch (error) {
    console.error("Error fetching ticket data:", error);
    // Update UI to show error state
    document.getElementById("ticket-problem").textContent =
      "Error loading ticket data";
    document.getElementById("ticket-cause").textContent = "Error";
    document.getElementById("ticket-actions").textContent = "Error";
    document.getElementById("ticket-result").textContent = "Error";
  }
}

/**
 * 티켓 메타데이터를 동적으로 렌더링하는 함수
 * 상태/우선순위 값에 따라 CSS 클래스를 동적으로 적용
 * @param {Object} metadata - 티켓 메타데이터 객체
 */
function renderTicketMetadata(metadata) {
  // 각 메타데이터 영역의 DOM 요소를 가져옴
  const titleEl = document.getElementById("ticket-title");
  const statusEl = document.getElementById("ticket-status");
  const priorityEl = document.getElementById("ticket-priority");
  const agentEl = document.getElementById("ticket-agent");
  const groupEl = document.getElementById("ticket-group");
  const createdAtEl = document.getElementById("ticket-created-at");
  const channelEl = document.getElementById("ticket-channel");
  const tagsEl = document.getElementById("ticket-tags");

  // 값이 존재할 때만 갱신
  if (titleEl && metadata.title) titleEl.textContent = metadata.title;
  if (statusEl && metadata.status) {
    statusEl.textContent = metadata.status;
    // 상태별 색상 강조 클래스 적용
    statusEl.className =
      "metadata-value status-label " + getStatusClass(metadata.status);
  }
  if (priorityEl && metadata.priority) {
    priorityEl.textContent = metadata.priority;
    // 우선순위별 색상 강조 클래스 적용
    priorityEl.className =
      "metadata-value priority-label " + getPriorityClass(metadata.priority);
  }
  if (agentEl && metadata.agent) agentEl.textContent = metadata.agent;
  if (groupEl && metadata.group) groupEl.textContent = metadata.group;
  if (createdAtEl && metadata.created_at)
    createdAtEl.textContent = metadata.created_at;
  if (channelEl && metadata.channel) channelEl.textContent = metadata.channel;
  if (tagsEl && metadata.tags)
    tagsEl.textContent = Array.isArray(metadata.tags)
      ? metadata.tags.join(", ")
      : metadata.tags;
}

// partial 데이터 수신 시 메타데이터 영역 갱신
function handlePartialData(partial) {
  // ...기존 영역별 렌더링 로직...
  if (partial.metadata) {
    // 티켓 메타데이터가 포함된 경우 동적으로 렌더링
    renderTicketMetadata(partial.metadata);
  }
  // ...summary, similar-tickets, suggested-solutions 등 기존 렌더링...
}

// SSE 수신부에서 partial 데이터 처리 시 handlePartialData 호출하도록 연결
// 예시:
// eventSource.onmessage = function(event) {
//     const partial = JSON.parse(event.data);
//     handlePartialData(partial);
// };

/**
 * 현재 티켓 ID를 가져오는 헬퍼 함수
 */
function getCurrentTicketId() {
  // URL에서 티켓 ID 추출 시도
  const urlParams = new URLSearchParams(window.location.search);
  let ticketId = urlParams.get("ticket_id");

  if (!ticketId) {
    // 글로벌 변수에서 티켓 ID 찾기
    if (window.ticketInitData && window.ticketInitData.ticket_id) {
      ticketId = window.ticketInitData.ticket_id;
    }
  }

  if (!ticketId) {
    // Freshdesk context에서 티켓 ID 찾기 (만약 Freshdesk FDK를 사용한다면)
    try {
      if (typeof app !== "undefined" && app.initialized) {
        // Freshdesk app context가 있는 경우
        app.get("ticket").then(function (ticketData) {
          ticketId = ticketData.ticket.id;
        });
      }
    } catch (e) {
      console.warn("Freshdesk context에서 티켓 ID를 가져올 수 없습니다:", e);
    }
  }

  return ticketId;
}

/**
 * SSE (Server-Sent Events) 스트리밍을 통한 실시간 쿼리 처리
 * 사용자가 질문할 때 백엔드에서 실시간으로 응답을 스트리밍 받습니다.
 */
function executeStreamingQuery(query, ticketId = null) {
  return new Promise((resolve, reject) => {
    try {
      console.log("🔄 SSE 스트리밍 쿼리 시작:", query);

      // EventSource를 통한 SSE 연결
      const eventSource = new EventSource(`${getBackendUrl()}/query/stream`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Company-ID": "default",
        },
        body: JSON.stringify({
          query: query,
          ticket_id: ticketId,
          top_k: 5,
          type: ["tickets", "solutions"],
        }),
      });

      let finalResult = null;

      // 진행 상황 이벤트 처리
      eventSource.addEventListener("progress", (event) => {
        try {
          const progressData = JSON.parse(event.data);
          console.log("📊 진행 상황:", progressData);

          // UI에 진행 상황 표시
          updateProgressUI(progressData);
        } catch (e) {
          console.warn("진행 상황 파싱 오류:", e);
        }
      });

      // 최종 결과 이벤트 처리
      eventSource.addEventListener("result", (event) => {
        try {
          const resultData = JSON.parse(event.data);
          console.log("✅ 최종 결과 수신:", resultData);

          finalResult = resultData;
          eventSource.close();
          resolve(finalResult);
        } catch (e) {
          console.error("결과 파싱 오류:", e);
          eventSource.close();
          reject(e);
        }
      });

      // 에러 이벤트 처리
      eventSource.addEventListener("error", (event) => {
        try {
          const errorData = JSON.parse(event.data);
          console.error("❌ 스트리밍 에러:", errorData);

          eventSource.close();
          reject(new Error(errorData.message || "스트리밍 중 오류 발생"));
        } catch (e) {
          console.error("에러 파싱 실패:", e);
          eventSource.close();
          reject(new Error("스트리밍 연결 오류"));
        }
      });

      // 연결 에러 처리
      eventSource.onerror = (error) => {
        console.error("EventSource 연결 오류:", error);
        eventSource.close();
        reject(new Error("서버 연결 실패"));
      };

      // 타임아웃 설정 (30초)
      setTimeout(() => {
        if (eventSource.readyState !== EventSource.CLOSED) {
          console.warn("⏰ SSE 스트리밍 타임아웃");
          eventSource.close();
          reject(new Error("요청 시간 초과"));
        }
      }, 30000);
    } catch (error) {
      console.error("SSE 스트리밍 시작 오류:", error);
      reject(error);
    }
  });
}

/**
 * SSE 스트리밍을 통한 응답 생성
 * 고객 대응용 답변을 실시간으로 생성합니다.
 */
function executeStreamingReplyGeneration(
  contextId,
  style = "professional",
  tone = "helpful"
) {
  return new Promise((resolve, reject) => {
    try {
      console.log("🔄 SSE 스트리밍 응답 생성 시작:", contextId);

      // EventSource를 통한 SSE 연결
      const eventSource = new EventSource(
        `${getBackendUrl()}/generate_reply/stream`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            context_id: contextId,
            style: style,
            tone: tone,
            include_greeting: true,
            include_signature: true,
          }),
        }
      );

      let finalResult = null;

      // 진행 상황 이벤트 처리
      eventSource.addEventListener("progress", (event) => {
        try {
          const progressData = JSON.parse(event.data);
          console.log("📊 응답 생성 진행:", progressData);

          // UI에 진행 상황 표시
          updateReplyGenerationProgressUI(progressData);
        } catch (e) {
          console.warn("진행 상황 파싱 오류:", e);
        }
      });

      // 최종 결과 이벤트 처리
      eventSource.addEventListener("result", (event) => {
        try {
          const resultData = JSON.parse(event.data);
          console.log("✅ 응답 생성 완료:", resultData);

          finalResult = resultData;
          eventSource.close();
          resolve(finalResult);
        } catch (e) {
          console.error("결과 파싱 오류:", e);
          eventSource.close();
          reject(e);
        }
      });

      // 에러 이벤트 처리
      eventSource.addEventListener("error", (event) => {
        try {
          const errorData = JSON.parse(event.data);
          console.error("❌ 응답 생성 에러:", errorData);

          eventSource.close();
          reject(new Error(errorData.message || "응답 생성 중 오류 발생"));
        } catch (e) {
          console.error("에러 파싱 실패:", e);
          eventSource.close();
          reject(new Error("응답 생성 연결 오류"));
        }
      });

      // 연결 에러 처리
      eventSource.onerror = (error) => {
        console.error("EventSource 연결 오류:", error);
        eventSource.close();
        reject(new Error("서버 연결 실패"));
      };

      // 타임아웃 설정 (60초 - 응답 생성은 더 오래 걸릴 수 있음)
      setTimeout(() => {
        if (eventSource.readyState !== EventSource.CLOSED) {
          console.warn("⏰ 응답 생성 스트리밍 타임아웃");
          eventSource.close();
          reject(new Error("응답 생성 시간 초과"));
        }
      }, 60000);
    } catch (error) {
      console.error("응답 생성 스트리밍 시작 오류:", error);
      reject(error);
    }
  });
}

/**
 * 백엔드 URL을 가져오는 헬퍼 함수
 */
function getBackendUrl() {
  // ngrok 주소 사용 (실제 환경에서는 환경 변수나 설정에서 가져와야 함)
  return "https://be33-58-122-170-2.ngrok-free.app";
}

/**
 * 쿼리 진행 상황 UI 업데이트
 */
function updateProgressUI(progressData) {
  try {
    const progressContainer = document.getElementById("query-progress");
    if (!progressContainer) return;

    const { step, message, progress } = progressData;

    // 진행률 바 업데이트
    const progressBar = progressContainer.querySelector(".progress-bar");
    const progressText = progressContainer.querySelector(".progress-text");
    const progressMessage =
      progressContainer.querySelector(".progress-message");

    if (progressBar && progress >= 0) {
      progressBar.style.width = `${progress}%`;
    }

    if (progressText && progress >= 0) {
      progressText.textContent = `${progress}%`;
    }

    if (progressMessage && message) {
      progressMessage.textContent = message;
    }

    // 단계별 아이콘 업데이트
    updateStepIcon(step);
  } catch (error) {
    console.warn("진행 상황 UI 업데이트 오류:", error);
  }
}

/**
 * 응답 생성 진행 상황 UI 업데이트
 */
function updateReplyGenerationProgressUI(progressData) {
  try {
    const progressContainer = document.getElementById(
      "reply-generation-progress"
    );
    if (!progressContainer) return;

    const { step, message, progress } = progressData;

    // 진행률 바 업데이트
    const progressBar = progressContainer.querySelector(".progress-bar");
    const progressText = progressContainer.querySelector(".progress-text");
    const progressMessage =
      progressContainer.querySelector(".progress-message");

    if (progressBar && progress >= 0) {
      progressBar.style.width = `${progress}%`;
    }

    if (progressText && progress >= 0) {
      progressText.textContent = `${progress}%`;
    }

    if (progressMessage && message) {
      progressMessage.textContent = message;
    }

    // 단계별 아이콘 업데이트
    updateReplyStepIcon(step);
  } catch (error) {
    console.warn("응답 생성 진행 상황 UI 업데이트 오류:", error);
  }
}

/**
 * 단계별 아이콘 업데이트
 */
function updateStepIcon(step) {
  const stepIcons = {
    start: "🚀",
    ticket_processing: "📋",
    searching: "🔍",
    processing: "⚙️",
    optimizing: "🎯",
    generating: "🤖",
    completed: "✅",
    error: "❌",
  };

  const icon = stepIcons[step] || "🔄";
  const iconElement = document.querySelector(".step-icon");
  if (iconElement) {
    iconElement.textContent = icon;
  }
}

/**
 * 응답 생성 단계별 아이콘 업데이트
 */
function updateReplyStepIcon(step) {
  const stepIcons = {
    start: "🚀",
    loading_context: "📂",
    extracting_metadata: "📊",
    building_context: "🔨",
    generating_reply: "✍️",
    completed: "✅",
    error: "❌",
  };

  const icon = stepIcons[step] || "🔄";
  const iconElement = document.querySelector(".reply-step-icon");
  if (iconElement) {
    iconElement.textContent = icon;
  }
}

/**
 * 새로운 HTML 구조에 맞게 티켓 정보를 업데이트하는 함수
 * @param {Object} ticketData - 백엔드에서 받은 티켓 데이터
 */
function updateTicketSummaryCard(ticketData) {
  try {
    console.log("🎨 티켓 요약 카드 업데이트 시작:", ticketData);

    // 티켓 메타 정보 업데이트
    updateElement(
      "ticket-title",
      ticketData.subject || ticketData.title || "제목 없음"
    );

    // 티켓 ID 업데이트
    updateElement("ticket-id", ticketData.id);

    // 메타정보 업데이트
    if (ticketData) {
      // 상태
      const statusEl = document.getElementById("ticket-status");
      if (statusEl) {
        statusEl.textContent = getStatusDisplayName(ticketData.status);
        statusEl.className = `meta-value ${getStatusClass(ticketData.status)}`;
      }

      // 우선순위
      const priorityEl = document.getElementById("ticket-priority");
      if (priorityEl) {
        priorityEl.textContent = getPriorityDisplayName(ticketData.priority);
        priorityEl.className = `meta-value ${getPriorityClass(
          ticketData.priority
        )}`;
      }

      // 담당자
      const assigneeEl = document.getElementById("ticket-assignee");
      if (assigneeEl) {
        assigneeEl.textContent = ticketData.responder_id
          ? ticketData.responder_name
          : "미지정";
      }

      // 요청자
      const requesterEl = document.getElementById("ticket-requester");
      if (requesterEl) {
        requesterEl.textContent = ticketData.requester_name || "알 수 없음";
      }

      // 채널
      const channelEl = document.getElementById("ticket-channel");
      if (channelEl) {
        channelEl.textContent = getChannelDisplayName(ticketData.source);
      }

      // 생성일
      const createdEl = document.getElementById("ticket-created");
      if (createdEl && ticketData.created_at) {
        createdEl.textContent = formatDate(ticketData.created_at);
      }
    }
  } catch (error) {
    console.error("❌ 티켓 요약 카드 업데이트 오류:", error);
  }
}

/**
 * 티켓 태그 업데이트
 */
function updateTicketTags(initData) {
  try {
    const tagsContainer = document.getElementById("ticket-tags");
    if (!tagsContainer) return;

    tagsContainer.innerHTML = ""; // 기존 태그 초기화

    if (initData.ticket_metadata && initData.ticket_metadata.tags) {
      const tags = initData.ticket_metadata.tags;

      if (Array.isArray(tags) && tags.length > 0) {
        tags.forEach((tag, index) => {
          const tagEl = document.createElement("span");
          tagEl.className = `tag ${getTagClass(index)}`;
          tagEl.textContent = tag;
          tagsContainer.appendChild(tagEl);
        });
      } else {
        // 기본 태그 표시
        const defaultTags = ["Support", "Technical"];
        defaultTags.forEach((tag, index) => {
          const tagEl = document.createElement("span");
          tagEl.className = `tag ${getTagClass(index)}`;
          tagEl.textContent = tag;
          tagsContainer.appendChild(tagEl);
        });
      }
    }
  } catch (error) {
    console.error("❌ 태그 업데이트 오류:", error);
  }
}

/**
 * Problem/Result 섹션 업데이트
 */
function updateProblemResultSection(initData) {
  try {
    if (initData.summary) {
      // AI 요약이 있는 경우 해당 내용 사용
      const problemEl = document.getElementById("ticket-problem");
      const causeEl = document.getElementById("ticket-cause");
      const resultEl = document.getElementById("ticket-result");
      const actionsEl = document.getElementById("ticket-actions");

      if (problemEl) {
        problemEl.textContent =
          initData.summary.problem || "문제 상황을 분석 중입니다...";
      }
      if (causeEl) {
        causeEl.textContent =
          initData.summary.cause || "원인을 분석 중입니다...";
      }
      if (resultEl) {
        resultEl.textContent =
          initData.summary.solution || "해결 방안을 제안 중입니다...";
      }
      if (actionsEl) {
        actionsEl.textContent =
          initData.summary.actions || "처리 결과를 확인 중입니다...";
      }
    } else if (initData.ticket_metadata) {
      // 티켓 메타데이터만 있는 경우 기본 내용 표시
      const problemEl = document.getElementById("ticket-problem");
      if (problemEl && initData.ticket_metadata.description) {
        problemEl.textContent =
          initData.ticket_metadata.description.substring(0, 200) + "...";
      }
    }
  } catch (error) {
    console.error("❌ Problem/Result 섹션 업데이트 오류:", error);
  }
}

/**
 * 첨부파일 섹션 업데이트
 */
function updateAttachmentsSection(initData) {
  try {
    const attachmentSection = document.getElementById("attachment-section");
    const attachmentsList = document.getElementById("attachments-list");

    if (!attachmentSection || !attachmentsList) return;

    if (
      initData.ticket_metadata &&
      initData.ticket_metadata.attachments &&
      initData.ticket_metadata.attachments.length > 0
    ) {
      attachmentSection.style.display = "block";
      attachmentsList.innerHTML = "";

      initData.ticket_metadata.attachments.forEach((attachment) => {
        const attachmentEl = document.createElement("div");
        attachmentEl.className = "attachment-item";

        attachmentEl.innerHTML = `
          <span class="attachment-icon">📎</span>
          <span class="attachment-name">${attachment.name}</span>
          <a href="${attachment.attachment_url}" target="_blank" class="attachment-link">
            다운로드
          </a>
        `;

        attachmentsList.appendChild(attachmentEl);
      });
    } else {
      attachmentSection.style.display = "none";
    }
  } catch (error) {
    console.error("❌ 첨부파일 섹션 업데이트 오류:", error);
  }
}

/**
 * 탭 컨텐츠 업데이트
 */
function updateTabContents(initData) {
  try {
    // Similar Tickets 탭 업데이트
    if (initData.similar_tickets && initData.similar_tickets.length > 0) {
      updateSimilarTicketsList(initData.similar_tickets);
    }

    // Suggested Solutions 탭 업데이트
    if (initData.kb_docs && initData.kb_docs.length > 0) {
      updateSolutionsList(initData.kb_docs);
    }
  } catch (error) {
    console.error("❌ 탭 컨텐츠 업데이트 오류:", error);
  }
}

/**
 * 유사 티켓 리스트 업데이트
 */
function updateSimilarTicketsList(similarTickets) {
  try {
    const listContainer = document.getElementById("similar-tickets-list");
    if (!listContainer) return;

    listContainer.innerHTML = "";

    similarTickets.forEach((ticket) => {
      const ticketEl = document.createElement("div");
      ticketEl.className = "similar-ticket-item";

      ticketEl.innerHTML = `
        <div class="similar-ticket-header">
          <span class="similar-ticket-id">#${ticket.id}</span>
          <span class="search-result-score">${Math.round(
            (ticket.score || 0) * 100
          )}%</span>
        </div>
        <h4 class="similar-ticket-title">${ticket.subject || "제목 없음"}</h4>
        <p class="similar-ticket-description">
          ${(ticket.description || "설명 없음").substring(0, 150)}...
        </p>
      `;

      listContainer.appendChild(ticketEl);
    });
  } catch (error) {
    console.error("❌ 유사 티켓 리스트 업데이트 오류:", error);
  }
}

/**
 * 솔루션 리스트 업데이트
 */
function updateSolutionsList(solutions) {
  try {
    const listContainer = document.getElementById("solutions-list");
    if (!listContainer) return;

    listContainer.innerHTML = "";

    solutions.forEach((solution) => {
      const solutionEl = document.createElement("div");
      solutionEl.className = "solution-item";

      solutionEl.innerHTML = `
        <div class="solution-header">
          <span class="solution-id">KB-${solution.id}</span>
          <span class="search-result-score">${Math.round(
            (solution.score || 0) * 100
          )}%</span>
        </div>
        <h4 class="solution-title">${solution.title || "제목 없음"}</h4>
        <p class="solution-content">
          ${(solution.content || "내용 없음").substring(0, 200)}...
        </p>
      `;

      listContainer.appendChild(solutionEl);
    });
  } catch (error) {
    console.error("❌ 솔루션 리스트 업데이트 오류:", error);
  }
}

/**
 * Freshdesk에서 직접 티켓 메타데이터 로딩
 */
async function loadTicketMetadataFromFreshdesk() {
  try {
    console.log("🔄 Freshdesk에서 티켓 메타데이터 로딩");

    const data = await client.data.get("ticket");
    const ticket = data.ticket;

    // Freshdesk 필드명에 맞춰 조정
    const metadata = {
      id: ticket.id,
      subject: ticket.subject,
      description: ticket.description_text || ticket.description,
      status: ticket.status,
      priority: ticket.priority,
      assignee_id: ticket.responder_id,
      assignee_name: ticket.responder_id ? ticket.responder_name : "미지정",
      requester_id: ticket.requester_id,
      requester_name: ticket.requester?.name || "알 수 없음",
      source: ticket.source,
      created_at: ticket.created_at,
      updated_at: ticket.updated_at,
      tags: ticket.tags || [],
      attachments: ticket.attachments || [],
    };

    // 전역 변수에 저장
    if (!window.ticketInitData) {
      window.ticketInitData = {};
    }
    window.ticketInitData.ticket_metadata = metadata;

    console.log("✅ Freshdesk 티켓 메타데이터 로딩 완료:", metadata);

    // UI 업데이트
    updateTicketSummaryCard({ ticket_metadata: metadata });
    updateTicketTags({ ticket_metadata: metadata });
    updateAttachmentsSection({ ticket_metadata: metadata });

    return metadata;
  } catch (error) {
    console.error("❌ Freshdesk 티켓 메타데이터 로딩 오류:", error);

    // 에러 발생 시 기본값으로 표시
    updateTicketSummaryCard({
      subject: "티켓 정보 로딩 실패",
      status: 2,
      priority: 2,
      source: 1,
    });
  }
}

/**
 * 유틸리티 함수들
 */

function getStatusDisplayName(status) {
  const statusMap = {
    2: "열림",
    3: "보류",
    4: "해결됨",
    5: "닫힘",
  };
  return statusMap[status] || "알 수 없음";
}

function getStatusClass(status) {
  const classMap = {
    2: "status-open",
    3: "status-pending",
    4: "status-closed",
    5: "status-closed",
  };
  return classMap[status] || "status-open";
}

function getPriorityDisplayName(priority) {
  const priorityMap = {
    1: "낮음",
    2: "보통",
    3: "높음",
    4: "긴급",
  };
  return priorityMap[priority] || "보통";
}

function getPriorityClass(priority) {
  const classMap = {
    1: "priority-low",
    2: "priority-medium",
    3: "priority-high",
    4: "priority-high",
  };
  return classMap[priority] || "priority-medium";
}

function getChannelDisplayName(source) {
  const sourceMap = {
    1: "이메일",
    2: "포털",
    3: "전화",
    7: "채팅",
    8: "피드백 위젯",
    9: "아웃바운드 이메일",
  };
  return sourceMap[source] || "이메일";
}

function getTagClass(index) {
  const classes = ["tag-blue", "tag-green", "tag-orange", "tag-gray"];
  return classes[index % classes.length];
}

function formatDate(dateString) {
  try {
    const date = new Date(dateString);
    return date.toLocaleDateString("ko-KR", {
      year: "numeric",
      month: "short",
      day: "numeric",
    });
  } catch (error) {
    return "날짜 오류";
  }
}

/**
 * Copilot 검색 수행
 */
async function performCopilotSearch() {
  try {
    const inputEl = document.getElementById("copilot-input");
    const resultsEl = document.getElementById("copilot-results");
    const searchBtn = document.getElementById("copilot-search-btn");

    if (!inputEl || !resultsEl) {
      console.error("Copilot 요소를 찾을 수 없습니다");
      return;
    }

    const query = inputEl.value.trim();
    if (!query) {
      console.warn("검색어가 비어있습니다");
      return;
    }

    // 로딩 상태 표시
    searchBtn.textContent = "검색 중...";
    searchBtn.disabled = true;

    resultsEl.innerHTML = `
      <div class="loading-placeholder">
        <span class="loading-icon">🔄</span>
        <span>AI가 답변을 생성하고 있습니다...</span>
      </div>
    `;

    // 검색 범위 가져오기
    const searchScope = getSearchScope();

    // 백엔드 API 호출
    const response = await client.request.invoke("backendApi", {
      context: {
        path: "/query",
      },
      body: JSON.stringify({
        query: query,
        ticket_id: window.ticketInitData?.ticket_id,
        search_scope: searchScope,
      }),
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    });

    console.log("✅ Copilot 검색 응답:", response);

    // 검색 결과 표시
    displaySearchResults(response.response, query);
  } catch (error) {
    console.error("❌ Copilot 검색 오류:", error);

    const resultsEl = document.getElementById("copilot-results");
    if (resultsEl) {
      resultsEl.innerHTML = `
        <div class="error-message">
          <span class="error-icon">❌</span>
          <p>검색 중 오류가 발생했습니다. 다시 시도해 주세요.</p>
        </div>
      `;
    }
  } finally {
    // 버튼 상태 복원
    const searchBtn = document.getElementById("copilot-search-btn");
    if (searchBtn) {
      searchBtn.textContent = "검색";
      searchBtn.disabled = false;
    }
  }
}

/**
 * 검색 범위 가져오기
 */
function getSearchScope() {
  const scope = [];

  if (document.getElementById("scope-tickets")?.checked) {
    scope.push("tickets");
  }
  if (document.getElementById("scope-solutions")?.checked) {
    scope.push("solutions");
  }
  if (document.getElementById("scope-images")?.checked) {
    scope.push("images");
  }
  if (document.getElementById("scope-attachments")?.checked) {
    scope.push("attachments");
  }

  return scope;
}

/**
 * 검색 결과 표시
 */
function displaySearchResults(results, query) {
  try {
    const resultsEl = document.getElementById("copilot-results");
    if (!resultsEl) return;

    if (
      !results ||
      (!results.tickets && !results.solutions && !results.answer)
    ) {
      resultsEl.innerHTML = `
        <div class="no-results">
          <span class="no-results-icon">🔍</span>
          <p>"${query}"에 대한 검색 결과가 없습니다.</p>
        </div>
      `;
      return;
    }

    let html = "";

    // AI 답변이 있는 경우
    if (results.answer) {
      html += `
        <div class="ai-answer">
          <h4>🤖 AI 답변</h4>
          <p>${results.answer}</p>
        </div>
      `;
    }

    // 검색된 티켓들
    if (results.tickets && results.tickets.length > 0) {
      html += "<h4>🎫 관련 티켓</h4>";
      results.tickets.forEach((ticket) => {
        html += `
          <div class="search-result-item">
            <div class="search-result-type">티켓</div>
            <h5 class="search-result-title">#${ticket.id} ${ticket.subject}</h5>
            <p class="search-result-content">${(
              ticket.description || ""
            ).substring(0, 200)}...</p>
            <span class="search-result-score">${Math.round(
              (ticket.score || 0) * 100
            )}%</span>
          </div>
        `;
      });
    }

    // 검색된 솔루션들
    if (results.solutions && results.solutions.length > 0) {
      html += "<h4>💡 관련 솔루션</h4>";
      results.solutions.forEach((solution) => {
        html += `
          <div class="search-result-item">
            <div class="search-result-type">솔루션</div>
            <h5 class="search-result-title">${solution.title}</h5>
            <p class="search-result-content">${(
              solution.content || ""
            ).substring(0, 200)}...</p>
            <span class="search-result-score">${Math.round(
              (solution.score || 0) * 100
            )}%</span>
          </div>
        `;
      });
    }

    resultsEl.innerHTML = html;
  } catch (error) {
    console.error("❌ 검색 결과 표시 오류:", error);
  }
}
