# Task ID: 7
# Title: Develop Context-Based Prompt Engineering
# Status: pending
# Dependencies: 5, 6
# Priority: medium
# Description: Create a system for dynamically constructing prompts based on ticket context, retrieved similar content, and user requirements.
# Details:
1. Design prompt templates for different use cases:
   - Ticket summarization
   - Response generation
   - Block rewriting
   - Question answering
2. Implement a context manager that can:
   - Combine ticket information
   - Add relevant knowledge base content
   - Include similar tickets
   - Format for specific LLM providers
3. Create a system for managing prompt length to avoid token limits
4. Implement relevance scoring for context selection
5. Add support for different languages
6. Create a template engine for prompt construction

Example code:
```python
class PromptTemplate:
    def __init__(self, template: str, max_context_length: int = 4000):
        self.template = template
        self.max_context_length = max_context_length
        
    def format(self, **kwargs):
        return self.template.format(**kwargs)
        
class ContextManager:
    def __init__(self, vector_store):
        self.vector_store = vector_store
        self.templates = {
            "summarize": PromptTemplate(
                "Summarize the following ticket:\n\nTicket: {ticket_text}\n\nSummary:"
            ),
            "reply": PromptTemplate(
                "Generate a helpful reply to the customer ticket below.\n\n"
                "Ticket: {ticket_text}\n\n"
                "Similar tickets: {similar_tickets}\n\n"
                "Knowledge base: {knowledge_base}\n\n"
                "Reply:"
            )
        }
        
    async def get_context(self, ticket, company_id, embedding_service):
        # Get ticket embedding
        ticket_text = ticket["subject"] + "\n" + ticket["description"]
        embedding = await embedding_service.get_embedding(ticket_text)
        
        # Get similar tickets
        similar_tickets = await self.vector_store.search(
            company_id, "tickets", embedding, limit=3
        )
        
        # Get relevant knowledge base articles
        kb_articles = await self.vector_store.search(
            company_id, "knowledge_base", embedding, limit=3
        )
        
        # Format context
        similar_tickets_text = "\n\n".join([item.payload["text"] for item in similar_tickets])
        kb_text = "\n\n".join([item.payload["text"] for item in kb_articles])
        
        return {
            "ticket_text": ticket_text,
            "similar_tickets": similar_tickets_text,
            "knowledge_base": kb_text
        }
        
    async def create_prompt(self, prompt_type, ticket, company_id, embedding_service):
        context = await self.get_context(ticket, company_id, embedding_service)
        template = self.templates.get(prompt_type)
        if not template:
            raise ValueError(f"Unknown prompt type: {prompt_type}")
            
        return template.format(**context)
```

# Test Strategy:
1. Test prompt generation with different contexts
2. Verify context truncation works correctly
3. Test relevance scoring for context selection
4. Validate language support
5. Test with various ticket types and content
6. Measure token usage for different prompts
7. Test template rendering with edge cases
8. Verify prompt effectiveness with actual LLM responses

# Subtasks:
## 1. Design prompt templates for different use cases [pending]
### Dependencies: None
### Description: Create specialized prompt templates that accommodate various use cases such as customer support, content generation, data analysis, and technical assistance
### Details:
Develop a library of prompt templates with placeholders for context insertion. Each template should include sections for directives, role definitions, context placement, and output formatting instructions. Consider different structures for factual queries versus creative tasks.

## 2. Implement context management and selection logic [pending]
### Dependencies: 7.1
### Description: Develop algorithms to select and prioritize relevant context from various sources based on the query and use case
### Details:
Create a context selection system that can retrieve information from knowledge bases, conversation history, and user profiles. Implement filtering mechanisms to remove irrelevant information and prioritize context based on recency, relevance, and importance to the query.

## 3. Build relevance scoring and context optimization system [pending]
### Dependencies: 7.2
### Description: Create a system to score context relevance and optimize context selection for maximum prompt effectiveness
### Details:
Implement semantic similarity algorithms to score context relevance to the query. Develop methods to summarize lengthy context while preserving key information. Create a ranking system that balances information completeness with token efficiency.

## 4. Develop template rendering with token management [pending]
### Dependencies: 7.1, 7.3
### Description: Create a rendering system that combines templates with selected context while managing token limits
### Details:
Build a template rendering engine that can dynamically insert context into templates while tracking token usage. Implement fallback mechanisms for when context exceeds token limits, including context truncation, summarization, or template simplification strategies.

