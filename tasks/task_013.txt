# Task ID: 13
# Title: Implement Security and Multi-tenant Isolation
# Status: deferred
# Dependencies: 1, 3, 12
# Priority: high
# Description: Implement security measures and multi-tenant data isolation to ensure customer data is properly segregated and protected.
# Details:
1. Implement API key authentication
2. Create middleware for request validation
3. Implement company_id based data isolation
4. Add rate limiting and throttling
5. Implement CORS configuration
6. Add security headers
7. Create audit logging for sensitive operations
8. Implement personal data masking

Example code:
```python
from fastapi import FastAPI, Request, Response, Depends, HTTPException, Security
from fastapi.security.api_key import APIKeyHeader, APIKey
from fastapi.middleware.cors import CORSMiddleware
from starlette.middleware.base import BaseHTTPMiddleware
import time
import re
import logging
from typing import List, Optional

app = FastAPI()

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://*.freshdesk.com"],  # Restrict to Freshdesk domains
    allow_credentials=True,
    allow_methods=["GET", "POST"],
    allow_headers=["*"],
)

# API Key authentication
API_KEY_NAME = "X-API-Key"
api_key_header = APIKeyHeader(name=API_KEY_NAME, auto_error=False)

async def get_api_key(api_key_header: str = Security(api_key_header)):
    if api_key_header is None:
        raise HTTPException(status_code=403, detail="API Key is missing")
        
    # In a real app, validate against stored keys
    valid_keys = {"test_key": 1}  # Map of API key to company_id
    
    if api_key_header not in valid_keys:
        raise HTTPException(status_code=403, detail="Invalid API Key")
        
    return {"api_key": api_key_header, "company_id": valid_keys[api_key_header]}

# Rate limiting middleware
class RateLimitMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, rate_limit_per_minute: int = 60):
        super().__init__(app)
        self.rate_limit = rate_limit_per_minute
        self.requests = {}  # IP/API Key -> list of timestamps
        
    async def dispatch(self, request: Request, call_next):
        # Get identifier (API key or IP)
        api_key = request.headers.get(API_KEY_NAME)
        identifier = api_key or request.client.host
        
        # Check rate limit
        now = time.time()
        minute_ago = now - 60
        
        # Clean old requests
        if identifier in self.requests:
            self.requests[identifier] = [t for t in self.requests[identifier] if t > minute_ago]
        else:
            self.requests[identifier] = []
            
        # Check if over limit
        if len(self.requests[identifier]) >= self.rate_limit:
            return Response(
                content='{"detail":"Rate limit exceeded"}',
                status_code=429,
                media_type="application/json"
            )
            
        # Add current request
        self.requests[identifier].append(now)
        
        # Process request
        response = await call_next(request)
        
        # Add security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["Content-Security-Policy"] = "default-src 'self'"
        
        return response

app.add_middleware(RateLimitMiddleware, rate_limit_per_minute=100)

# Company ID validation middleware
class CompanyIdMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        # Skip for non-API paths
        if not request.url.path.startswith("/api/"):
            return await call_next(request)
            
        # Get API key details
        api_key_header = request.headers.get(API_KEY_NAME)
        if not api_key_header:
            return await call_next(request)
            
        # In a real app, get company_id from validated API key
        valid_keys = {"test_key": 1}  # Map of API key to company_id
        if api_key_header not in valid_keys:
            return await call_next(request)
            
        api_company_id = valid_keys[api_key_header]
        
        # Check if body contains company_id
        if request.method == "POST":
            try:
                body = await request.json()
                if "company_id" in body and body["company_id"] != api_company_id:
                    return Response(
                        content='{"detail":"Company ID mismatch"}',
                        status_code=403,
                        media_type="application/json"
                    )
            except:
                # If body isn't JSON or can't be parsed, continue
                pass
                
        return await call_next(request)

app.add_middleware(CompanyIdMiddleware)

# Personal data masking
def mask_personal_data(text: str) -> str:
    # Mask email addresses
    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
    text = re.sub(email_pattern, "[EMAIL REDACTED]", text)
    
    # Mask phone numbers (simple pattern)
    phone_pattern = r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b'
    text = re.sub(phone_pattern, "[PHONE REDACTED]", text)
    
    # Mask credit card numbers
    cc_pattern = r'\b(?:\d{4}[-\s]?){3}\d{4}\b'
    text = re.sub(cc_pattern, "[CREDIT CARD REDACTED]", text)
    
    return text

# Audit logging
class AuditLogger:
    def __init__(self):
        self.logger = logging.getLogger("audit")
        self.logger.setLevel(logging.INFO)
        
    def log_access(self, company_id: int, user_id: str, resource_type: str, 
                   resource_id: str, action: str, status: str):
        self.logger.info({
            "company_id": company_id,
            "user_id": user_id,
            "resource_type": resource_type,
            "resource_id": resource_id,
            "action": action,
            "status": status,
            "timestamp": time.time()
        })

# Example protected endpoint
@app.post("/api/v1/protected_endpoint")
async def protected_endpoint(request: Request, api_key_info: dict = Depends(get_api_key)):
    # Access is allowed if we get here
    company_id = api_key_info["company_id"]
    
    # Log access
    audit_logger = request.app.state.audit_logger
    audit_logger.log_access(
        company_id=company_id,
        user_id="system",  # In a real app, get from request
        resource_type="protected_resource",
        resource_id="123",
        action="access",
        status="success"
    )
    
    # Process request for this company only
    return {"message": f"Processed request for company {company_id}"}
```

# Test Strategy:
1. Test API key authentication
2. Verify company_id validation and isolation
3. Test rate limiting with rapid requests
4. Verify CORS configuration with different origins
5. Test security headers are properly set
6. Validate personal data masking
7. Verify audit logging captures all required information
8. Test with invalid authentication scenarios

# Subtasks:
## 1. Implement Authentication and Authorization Mechanisms [pending]
### Dependencies: None
### Description: Set up robust authentication and authorization systems to secure the multi-tenant environment
### Details:
Implement role-based access control (RBAC) to manage permissions based on user roles. Set up multi-factor authentication (MFA) for enhanced security. Ensure 1:1 mapping between tenant's external IdP and application client to prevent unauthorized cross-tenant access. Use immutable custom attributes for tenant identification. Integrate with identity management solutions to enforce least privilege principles.

## 2. Develop Request Validation and Company_id Isolation [pending]
### Dependencies: 13.1
### Description: Create mechanisms to validate requests and ensure proper tenant isolation using company_id
### Details:
Implement tenant validation in every request. Create data segmentation based on company_id to ensure strict isolation between tenants. Use verified attributes only for tenant matching. Restrict users from modifying criteria that authorize access to tenants. Implement data classification and segmentation based on sensitivity levels. Apply encryption for data at rest and in transit using protocols like AES-256 and TLS/SSL.

## 3. Configure Rate Limiting and CORS [pending]
### Dependencies: 13.1, 13.2
### Description: Set up rate limiting to prevent abuse and configure proper CORS policies
### Details:
Implement API rate limiting per tenant to prevent denial of service attacks. Configure proper Cross-Origin Resource Sharing (CORS) policies to restrict access from unauthorized domains. Set up monitoring systems to detect and alert on unusual traffic patterns. Ensure compliance with security standards while maintaining performance. Implement centralized policy management for consistent application of security controls.

## 4. Establish Audit Logging and Personal Data Protection [pending]
### Dependencies: 13.1, 13.2, 13.3
### Description: Create comprehensive audit logging and implement personal data protection measures
### Details:
Implement centralized logging systems to track user actions and system events. Set up SIEM systems for log storage and analysis. Establish regular log review processes to identify suspicious activities. Ensure compliance with regulations like GDPR, HIPAA, and PCI DSS for personal data protection. Implement data encryption and masking for sensitive information. Create data retention and deletion policies in accordance with regulatory requirements.

