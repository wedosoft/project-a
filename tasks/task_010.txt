# Task ID: 10
# Title: Implement Similar Tickets and Documents Search API
# Status: deferred
# Dependencies: 3, 4, 5
# Priority: medium
# Description: Create API endpoints for retrieving similar tickets and knowledge base documents based on semantic search and metadata filtering.
# Details:
1. Implement `/similar_tickets` endpoint with filtering options
2. Create `/related_docs` endpoint for knowledge base retrieval
3. Add support for hybrid search (vector + keyword)
4. Implement metadata filtering (date, category, priority)
5. Add pagination support
6. Create relevance scoring and ranking
7. Implement highlighting of matching content

Example code:
```python
from fastapi import APIRouter, Depends, HTTPException, Request, Query
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
from datetime import datetime

router = APIRouter(prefix="/api/v1")

class SearchFilter(BaseModel):
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    categories: Optional[List[str]] = None
    priorities: Optional[List[str]] = None
    statuses: Optional[List[str]] = None
    keywords: Optional[str] = None

class SearchResult(BaseModel):
    id: str
    title: str
    content: str
    score: float
    metadata: Dict[str, Any]
    highlights: List[str]

class SearchResponse(BaseModel):
    results: List[SearchResult]
    total: int
    page: int
    per_page: int

@router.post("/similar_tickets", response_model=SearchResponse)
async def find_similar_tickets(
    ticket_id: int,
    company_id: int,
    filters: Optional[SearchFilter] = None,
    page: int = Query(1, ge=1),
    per_page: int = Query(10, ge=1, le=100),
    req: Request
):
    try:
        # Get services
        freshdesk_client = req.app.state.freshdesk_client
        vector_store = req.app.state.vector_store
        embedding_service = req.app.state.embedding_service
        
        # Get ticket data
        ticket = await freshdesk_client.get_ticket(ticket_id, company_id)
        ticket_text = ticket["subject"] + "\n" + ticket["description"]
        
        # Generate embedding
        embedding = await embedding_service.get_embedding(ticket_text)
        
        # Prepare filter
        search_filter = {}
        if filters:
            if filters.start_date or filters.end_date:
                date_filter = {}
                if filters.start_date:
                    date_filter["$gte"] = filters.start_date.isoformat()
                if filters.end_date:
                    date_filter["$lte"] = filters.end_date.isoformat()
                search_filter["created_at"] = date_filter
                
            if filters.statuses:
                search_filter["status"] = {"$in": filters.statuses}
                
            if filters.priorities:
                search_filter["priority"] = {"$in": filters.priorities}
        
        # Search for similar tickets
        search_results = await vector_store.search(
            company_id, 
            "tickets", 
            embedding, 
            limit=per_page,
            offset=(page-1)*per_page,
            filter=search_filter
        )
        
        # Get total count
        total_count = await vector_store.count(
            company_id,
            "tickets",
            filter=search_filter
        )
        
        # Format results
        results = []
        for item in search_results:
            # Generate highlights (simplified)
            highlights = []
            if filters and filters.keywords:
                text = item.payload.get("text", "")
                for keyword in filters.keywords.split():
                    if keyword.lower() in text.lower():
                        # Find the sentence containing the keyword
                        sentences = text.split(". ")
                        for sentence in sentences:
                            if keyword.lower() in sentence.lower():
                                highlights.append(sentence + ".")
                                break
            
            results.append(SearchResult(
                id=item.id,
                title=item.payload.get("subject", ""),
                content=item.payload.get("text", "")[:200] + "...",  # Preview
                score=item.score,
                metadata={
                    "ticket_id": item.payload.get("ticket_id"),
                    "created_at": item.payload.get("created_at"),
                    "status": item.payload.get("status"),
                    "priority": item.payload.get("priority")
                },
                highlights=highlights
            ))
        
        return SearchResponse(
            results=results,
            total=total_count,
            page=page,
            per_page=per_page
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Similar endpoint for /related_docs with knowledge base search
```

# Test Strategy:
1. Test search with different filter combinations
2. Verify pagination works correctly
3. Test hybrid search with keywords and vectors
4. Validate metadata filtering
5. Test relevance scoring and ranking
6. Verify highlight generation
7. Test with large result sets
8. Measure search performance with different query complexities

# Subtasks:
## 1. Implement Core Search Functionality [pending]
### Dependencies: None
### Description: Develop the core search service with both vector and keyword search capabilities
### Details:
Create the application layer for the search API that handles both vector embeddings and keyword-based search. Implement the search service component that processes queries and interacts with the database. Design the API gateway to route search requests appropriately. Include implementation of the interaction layer for handling authentication and request processing.

## 2. Develop Filtering and Pagination System [pending]
### Dependencies: 10.1
### Description: Implement metadata filtering capabilities and efficient pagination for search results
### Details:
Create a filtering system that allows querying based on metadata attributes. Implement pagination functionality with cursor-based navigation for large result sets. Design the database interaction components to handle filtered queries efficiently. Develop the API endpoints that accept filter parameters and pagination controls. Include performance optimization for filtered searches.

## 3. Build Relevance Scoring and Result Highlighting [pending]
### Dependencies: 10.1, 10.2
### Description: Implement algorithms for relevance scoring and text highlighting in search results
### Details:
Develop a relevance scoring system that combines vector similarity and keyword matching scores. Implement result highlighting functionality to emphasize matched terms in returned content. Create a recommendation service component that can enhance search results with related content. Design the response formatting system to include highlighted snippets and relevance information. Implement caching mechanisms for frequently accessed search patterns.

